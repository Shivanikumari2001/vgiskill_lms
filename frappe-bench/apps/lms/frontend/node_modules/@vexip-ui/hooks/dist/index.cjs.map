{"version":3,"file":"index.cjs","sources":["../../utils/dist/index.mjs","../src/listener.ts","../src/clickoutside.ts","../src/display.ts","../src/shared/utils.ts","../src/full-screen.ts","../src/hover.ts","../src/intersection.ts","../src/manual-ref.ts","../src/modifier.ts","../src/mounted.ts","../src/moving.ts","../src/pointer.ts","../../../node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../../node_modules/.pnpm/@floating-ui+core@1.7.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../../node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../../../node_modules/.pnpm/@floating-ui+dom@1.7.0/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/freeze.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/element.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/global.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/process.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/scheduler.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObservation.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverController.js","../../../node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserver.js","../src/resize.ts","../src/rtl.ts","../src/popper.ts","../src/theme.ts","../src/timer-record.ts","../src/trigger-handler.ts","../src/virtual.ts"],"sourcesContent":["const y = typeof window < \"u\";\nvar Ot;\nconst yn = y && ((Ot = window == null ? void 0 : window.navigator) == null ? void 0 : Ot.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent), re = Object.prototype.toString, oe = Object.prototype.hasOwnProperty;\nfunction B(t, e) {\n  return re.call(t) === `[object ${e}]`;\n}\nfunction Mn(t, e) {\n  return oe.call(t, e);\n}\nfunction M(t) {\n  return t != null;\n}\nfunction ie(t) {\n  return t == null;\n}\nfunction Sn(t) {\n  return typeof t == \"number\";\n}\nfunction se(t) {\n  return Number.isNaN(t);\n}\nfunction wn(t) {\n  return typeof t == \"string\";\n}\nfunction En(t) {\n  return typeof t == \"boolean\";\n}\nfunction An(t) {\n  return t === !0;\n}\nfunction Nn(t) {\n  return t === !1;\n}\nfunction Fn(t) {\n  return typeof t == \"symbol\";\n}\nfunction On(t) {\n  return typeof t == \"bigint\";\n}\nfunction $n(t) {\n  return Array.isArray(t);\n}\nfunction Y(t) {\n  return B(t, \"Object\");\n}\nfunction Tn(t) {\n  return !!t && typeof t.then == \"function\" && typeof t.catch == \"function\";\n}\nfunction $t(t) {\n  return typeof t == \"function\";\n}\nfunction Cn(t) {\n  return B(t, \"Set\");\n}\nfunction Rn(t) {\n  return B(t, \"Map\");\n}\nfunction _n(t) {\n  return B(t, \"Date\");\n}\nfunction kn(t) {\n  return B(t, \"RegExp\");\n}\nfunction xn(t) {\n  return Array.isArray(t) || typeof t == \"string\" ? t.length === 0 : t instanceof Map || t instanceof Set ? t.size === 0 : Y(t) ? Object.keys(t).length === 0 : typeof t == \"number\" ? se(t) : ie(t);\n}\nfunction Dn(t, e = !1) {\n  return !e && !y ? !1 : !!(t && \"nodeType\" in t);\n}\nfunction G(t) {\n  return M(t) && typeof t[Symbol.iterator] == \"function\";\n}\nfunction it() {\n}\nfunction ce() {\n  return !0;\n}\nfunction In() {\n  return !1;\n}\nfunction Ln(t, e = 1, n = 1) {\n  const r = [];\n  for (let o = 0; o < t; ++o)\n    r.push(e + o * n);\n  return r;\n}\nfunction ae(t) {\n  return Object.prototype.toString.call(t).slice(8, -1);\n}\nfunction Hn(t = 16) {\n  const e = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\", n = e.length;\n  let r = \"\";\n  for (; t--; )\n    r += e.charAt(Math.floor(Math.random() * n));\n  return r;\n}\nasync function Pn(t, e = {}) {\n  if (t.length) {\n    for (const [n, r] of t)\n      if (typeof n == \"function\" ? n() : n)\n        return typeof e.beforeMatchAny == \"function\" && await e.beforeMatchAny(), await r(), typeof e.afterMatchAny == \"function\" && await e.afterMatchAny(), !0;\n  }\n  return !1;\n}\nasync function Bn(t) {\n  if (!y) return !1;\n  try {\n    return await navigator.clipboard.writeText(t), !0;\n  } catch {\n    let e = !1;\n    const n = document.createElement(\"textarea\"), r = document.activeElement;\n    n.value = t, n.setAttribute(\"readonly\", \"\"), n.style.contain = \"strict\", n.style.position = \"absolute\", n.style.height = \"0\", n.style.fontSize = \"12pt\";\n    const o = document.getSelection(), i = o ? o.rangeCount > 0 && o.getRangeAt(0) : null;\n    return document.body.appendChild(n), n.select(), n.selectionStart = 0, n.selectionEnd = t.length, e = document.execCommand(\"copy\"), document.body.removeChild(n), i && (o.removeAllRanges(), o.addRange(i)), r && r.focus(), e;\n  }\n}\nconst fe = \"[-\\\\+]?\\\\d+%?\", ue = \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\", F = `(?:${ue})|(?:${fe})`, le = `[\\\\s|\\\\(]+(${F})[,|\\\\s]+(${F})[,|\\\\s]+(${F})\\\\s*\\\\)?`, U = `[\\\\s|\\\\(]+(${F})[,|\\\\s]+(${F})[,|\\\\s]+(${F})[,|\\\\s]+(${F})\\\\s*\\\\)?`, Tt = new RegExp(`rgb${le}`), Ct = new RegExp(`rgba${U}`), Rt = new RegExp(`hsl${U}`), _t = new RegExp(`hsla${U}`), kt = new RegExp(`hsv${U}`), xt = new RegExp(`hsva${U}`), Dt = /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, It = /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Lt = /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, Ht = /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, W = Object.freeze({\n  aliceblue: \"f0f8ff\",\n  antiquewhite: \"faebd7\",\n  aqua: \"0ff\",\n  aquamarine: \"7fffd4\",\n  azure: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \"000\",\n  blanchedalmond: \"ffebcd\",\n  blue: \"00f\",\n  blueviolet: \"8a2be2\",\n  brown: \"a52a2a\",\n  burlywood: \"deb887\",\n  burntsienna: \"ea7e5d\",\n  cadetblue: \"5f9ea0\",\n  chartreuse: \"7fff00\",\n  chocolate: \"d2691e\",\n  coral: \"ff7f50\",\n  cornflowerblue: \"6495ed\",\n  cornsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"0ff\",\n  darkblue: \"00008b\",\n  darkcyan: \"008b8b\",\n  darkgoldenrod: \"b8860b\",\n  darkgray: \"a9a9a9\",\n  darkgreen: \"006400\",\n  darkgrey: \"a9a9a9\",\n  darkkhaki: \"bdb76b\",\n  darkmagenta: \"8b008b\",\n  darkolivegreen: \"556b2f\",\n  darkorange: \"ff8c00\",\n  darkorchid: \"9932cc\",\n  darkred: \"8b0000\",\n  darksalmon: \"e9967a\",\n  darkseagreen: \"8fbc8f\",\n  darkslateblue: \"483d8b\",\n  darkslategray: \"2f4f4f\",\n  darkslategrey: \"2f4f4f\",\n  darkturquoise: \"00ced1\",\n  darkviolet: \"9400d3\",\n  deeppink: \"ff1493\",\n  deepskyblue: \"00bfff\",\n  dimgray: \"696969\",\n  dimgrey: \"696969\",\n  dodgerblue: \"1e90ff\",\n  firebrick: \"b22222\",\n  floralwhite: \"fffaf0\",\n  forestgreen: \"228b22\",\n  fuchsia: \"f0f\",\n  gainsboro: \"dcdcdc\",\n  ghostwhite: \"f8f8ff\",\n  gold: \"ffd700\",\n  goldenrod: \"daa520\",\n  gray: \"808080\",\n  green: \"008000\",\n  greenyellow: \"adff2f\",\n  grey: \"808080\",\n  honeydew: \"f0fff0\",\n  hotpink: \"ff69b4\",\n  indianred: \"cd5c5c\",\n  indigo: \"4b0082\",\n  ivory: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavender: \"e6e6fa\",\n  lavenderblush: \"fff0f5\",\n  lawngreen: \"7cfc00\",\n  lemonchiffon: \"fffacd\",\n  lightblue: \"add8e6\",\n  lightcoral: \"f08080\",\n  lightcyan: \"e0ffff\",\n  lightgoldenrodyellow: \"fafad2\",\n  lightgray: \"d3d3d3\",\n  lightgreen: \"90ee90\",\n  lightgrey: \"d3d3d3\",\n  lightpink: \"ffb6c1\",\n  lightsalmon: \"ffa07a\",\n  lightseagreen: \"20b2aa\",\n  lightskyblue: \"87cefa\",\n  lightslategray: \"789\",\n  lightslategrey: \"789\",\n  lightsteelblue: \"b0c4de\",\n  lightyellow: \"ffffe0\",\n  lime: \"0f0\",\n  limegreen: \"32cd32\",\n  linen: \"faf0e6\",\n  magenta: \"f0f\",\n  maroon: \"800000\",\n  mediumaquamarine: \"66cdaa\",\n  mediumblue: \"0000cd\",\n  mediumorchid: \"ba55d3\",\n  mediumpurple: \"9370db\",\n  mediumseagreen: \"3cb371\",\n  mediumslateblue: \"7b68ee\",\n  mediumspringgreen: \"00fa9a\",\n  mediumturquoise: \"48d1cc\",\n  mediumvioletred: \"c71585\",\n  midnightblue: \"191970\",\n  mintcream: \"f5fffa\",\n  mistyrose: \"ffe4e1\",\n  moccasin: \"ffe4b5\",\n  navajowhite: \"ffdead\",\n  navy: \"000080\",\n  oldlace: \"fdf5e6\",\n  olive: \"808000\",\n  olivedrab: \"6b8e23\",\n  orange: \"ffa500\",\n  orangered: \"ff4500\",\n  orchid: \"da70d6\",\n  palegoldenrod: \"eee8aa\",\n  palegreen: \"98fb98\",\n  paleturquoise: \"afeeee\",\n  palevioletred: \"db7093\",\n  papayawhip: \"ffefd5\",\n  peachpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pink: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powderblue: \"b0e0e6\",\n  purple: \"800080\",\n  rebeccapurple: \"663399\",\n  red: \"f00\",\n  rosybrown: \"bc8f8f\",\n  royalblue: \"4169e1\",\n  saddlebrown: \"8b4513\",\n  salmon: \"fa8072\",\n  sandybrown: \"f4a460\",\n  seagreen: \"2e8b57\",\n  seashell: \"fff5ee\",\n  sienna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyblue: \"87ceeb\",\n  slateblue: \"6a5acd\",\n  slategray: \"708090\",\n  slategrey: \"708090\",\n  snow: \"fffafa\",\n  springgreen: \"00ff7f\",\n  steelblue: \"4682b4\",\n  tan: \"d2b48c\",\n  teal: \"008080\",\n  thistle: \"d8bfd8\",\n  tomato: \"ff6347\",\n  turquoise: \"40e0d0\",\n  violet: \"ee82ee\",\n  wheat: \"f5deb3\",\n  white: \"fff\",\n  whitesmoke: \"f5f5f5\",\n  yellow: \"ff0\",\n  yellowgreen: \"9acd32\"\n}), de = Object.freeze(new Set(Object.keys(W)));\nfunction Un(t) {\n  return t = String(t).trim().toLowerCase(), t ? t === \"transparent\" || W[t] ? !0 : t === \"transparent\" || de.has(t) || Tt.test(t) || Ct.test(t) || Rt.test(t) || _t.test(t) || kt.test(t) || xt.test(t) || Dt.test(t) || It.test(t) || Lt.test(t) || Ht.test(t) : !1;\n}\nfunction he(t) {\n  if (t = t.toString().trim().toLowerCase(), t === \"transparent\")\n    return { r: 0, g: 0, b: 0, a: 0, format: \"name\", toString: S };\n  let e = !1;\n  W[t] && (t = W[t], e = !0);\n  let n;\n  if (n = Tt.exec(t)) {\n    const { r, g: o, b: i } = R(n[1], n[2], n[3]);\n    return {\n      r: r * 255,\n      g: o * 255,\n      b: i * 255,\n      format: \"rgb\",\n      toString: S\n    };\n  }\n  if (n = Ct.exec(t)) {\n    const { r, g: o, b: i } = R(n[1], n[2], n[3]);\n    return {\n      r: r * 255,\n      g: o * 255,\n      b: i * 255,\n      a: C(n[4]),\n      format: \"rgba\",\n      toString: S\n    };\n  }\n  if (n = Rt.exec(t)) {\n    const { h: r, s: o, l: i } = z(n[0], n[1], n[3]);\n    return { h: r * 360, s: o, l: i, format: \"hsl\", toString: H };\n  }\n  if (n = _t.exec(t)) {\n    const { h: r, s: o, l: i } = z(n[0], n[1], n[3]);\n    return {\n      h: r * 360,\n      s: o,\n      l: i,\n      a: C(n[4]),\n      format: \"hsla\",\n      toString: H\n    };\n  }\n  if (n = kt.exec(t)) {\n    const { h: r, s: o, v: i } = j(n[0], n[1], n[3]);\n    return { h: r * 360, s: o, v: i, format: \"hsv\", toString: q };\n  }\n  if (n = xt.exec(t)) {\n    const { h: r, s: o, v: i } = j(n[0], n[1], n[3]);\n    return {\n      h: r * 360,\n      s: o,\n      v: i,\n      a: C(n[4]),\n      format: \"hsva\",\n      toString: q\n    };\n  }\n  return (n = Dt.exec(t)) ? {\n    r: parseInt(`${n[1]}${n[1]}`, 16),\n    g: parseInt(`${n[2]}${n[2]}`, 16),\n    b: parseInt(`${n[3]}${n[3]}`, 16),\n    format: e ? \"name\" : \"hex3\",\n    toString: S\n  } : (n = It.exec(t)) ? {\n    r: parseInt(`${n[1]}${n[1]}`, 16),\n    g: parseInt(`${n[2]}${n[2]}`, 16),\n    b: parseInt(`${n[3]}${n[3]}`, 16),\n    a: mt(`${n[4]}${n[4]}`),\n    format: e ? \"name\" : \"hex4\",\n    toString: S\n  } : (n = Lt.exec(t)) ? {\n    r: parseInt(n[1], 16),\n    g: parseInt(n[2], 16),\n    b: parseInt(n[3], 16),\n    format: e ? \"name\" : \"hex6\",\n    toString: S\n  } : (n = Ht.exec(t)) ? {\n    r: parseInt(n[1], 16),\n    g: parseInt(n[2], 16),\n    b: parseInt(n[3], 16),\n    a: mt(n[4]),\n    format: e ? \"name\" : \"hex8\",\n    toString: S\n  } : null;\n}\nfunction Yn(t) {\n  const { a: e, ...n } = O(t);\n  delete n.format;\n  const r = Bt(n.r, n.g, n.b), o = Ut(n.r, n.g, n.b), i = st(n.r, n.g, n.b), s = ct(n.r, n.g, n.b, e);\n  return {\n    rgb: n,\n    hsl: r,\n    hsv: o,\n    hex: i,\n    alpha: e,\n    rgba: { ...n, a: e, format: \"rgba\" },\n    hsla: { ...r, a: e, format: \"hsla\" },\n    hsva: { ...o, a: e, format: \"hsva\" },\n    hex8: s,\n    gray: Gt(n),\n    origin: t\n  };\n}\nfunction O(t) {\n  let e = { r: 0, g: 0, b: 0 }, n = 1, r;\n  return typeof t == \"string\" ? r = he(t) : r = t, r !== null && typeof r == \"object\" && (\"l\" in r ? e = Pt(r.h, r.s, r.l) : \"v\" in r && (e = pe(r.h, r.s, r.v)), \"a\" in r && (n = C(r.a ?? 1), Number.isNaN(n) && (n = 1)), e = r), { ...e, a: n, format: \"rgba\", toString: S };\n}\nfunction z(t, e, n) {\n  return {\n    h: w(t, 0, 360) / 360,\n    s: w(I(e) ? L(e) : e, 0, 1),\n    l: w(I(n) ? L(n) : n, 0, 1)\n  };\n}\nfunction R(t, e, n) {\n  return {\n    r: w(t, 0, 255) / 255,\n    g: w(e, 0, 255) / 255,\n    b: w(n, 0, 255) / 255\n  };\n}\nfunction j(t, e, n) {\n  return {\n    h: w(t, 0, 360) / 360,\n    s: w(I(e) ? L(e) : e, 0, 1),\n    v: w(I(n) ? L(n) : n, 0, 1)\n  };\n}\nfunction C(t) {\n  return w(I(t) ? L(t) : t, 0, 1);\n}\nfunction Pt(t, e, n) {\n  let r, o, i;\n  if ({ h: t, s: e, l: n } = z(t, e, n), e === 0)\n    r = o = i = n;\n  else {\n    const s = n < 0.5 ? 1 * (1 + e) : n + e - n * e, c = 2 * n - s;\n    r = tt(c, s, t + 1 / 3), o = tt(c, s, t), i = tt(c, s, t - 1 / 3);\n  }\n  return r *= 255, o *= 255, i *= 255, { r, g: o, b: i, toString: S };\n}\nfunction Bt(t, e, n) {\n  ({ r: t, g: e, b: n } = R(t, e, n));\n  const r = Math.max(t, e, n), o = Math.min(t, e, n);\n  let i, s;\n  const c = (r + o) / 2;\n  if (r === o)\n    i = s = 0;\n  else {\n    const a = r - o;\n    switch (s = c > 0.5 ? a / (2 - r - o) : a / (r + o), r) {\n      case t: {\n        i = (e - n) / a + (e < n ? 6 : 0);\n        break;\n      }\n      case e: {\n        i = (n - t) / a + 2;\n        break;\n      }\n      case n: {\n        i = (t - e) / a + 4;\n        break;\n      }\n      default:\n        i = 0;\n    }\n    i *= 60;\n  }\n  return { h: i, s, l: c, toString: H };\n}\nfunction ge(t, e, n) {\n  ({ h: t, s: e, l: n } = z(t, e, n));\n  const r = 0.5 * (2 * n + e * (1 - Math.abs(2 * n - 1)));\n  return e = 2 * (r - n) / r, { h: t * 360, s: e, v: r, toString: q };\n}\nfunction Gn(t, e, n) {\n  ({ h: t, s: e, v: n } = j(t, e, n));\n  const r = 0.5 * n * (2 - e);\n  return e = n * e / (1 - Math.abs(2 * r - 1)), { h: t * 360, s: e, l: r, toString: H };\n}\nfunction pe(t, e, n) {\n  ({ h: t, s: e, v: n } = j(t, e, n)), t *= 6;\n  const r = Math.floor(t), o = t - r, i = n * (1 - e), s = n * (1 - o * e), c = n * (1 - (1 - o) * e), a = r % 6;\n  let f = [n, s, i, i, c, n][a], u = [c, n, n, s, i, i][a], d = [i, i, c, n, n, s][a];\n  return f *= 255, u *= 255, d *= 255, { r: f, g: u, b: d, toString: S };\n}\nfunction Ut(t, e, n) {\n  ({ r: t, g: e, b: n } = R(t, e, n));\n  const r = Math.max(t, e, n), o = Math.min(t, e, n);\n  let i;\n  const s = r, c = r - o, a = r === 0 ? 0 : c / r;\n  if (r === o)\n    i = 0;\n  else {\n    switch (r) {\n      case t: {\n        i = (e - n) / c + (e < n ? 6 : 0);\n        break;\n      }\n      case e: {\n        i = (n - t) / c + 2;\n        break;\n      }\n      case n: {\n        i = (t - e) / c + 4;\n        break;\n      }\n      default:\n        i = 0;\n    }\n    i *= 60;\n  }\n  return { h: i, s: a, v: s, toString: q };\n}\nfunction st(t, e, n, r = !1) {\n  ({ r: t, g: e, b: n } = R(t, e, n));\n  const o = [\n    $(Math.round(t * 255).toString(16)),\n    $(Math.round(e * 255).toString(16)),\n    $(Math.round(n * 255).toString(16))\n  ];\n  return r && T(o[0]) && T(o[1]) && T(o[2]) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) : \"#\" + o.join(\"\");\n}\nfunction ct(t, e, n, r, o = !1) {\n  ({ r: t, g: e, b: n } = R(t, e, n));\n  const i = [\n    $(Math.round(t * 255).toString(16)),\n    $(Math.round(e * 255).toString(16)),\n    $(Math.round(n * 255).toString(16)),\n    $(me(C(r)))\n  ];\n  return o && T(i[0]) && T(i[1]) && T(i[2]) && T(i[3]) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) + i[3].charAt(0) : \"#\" + i.join(\"\");\n}\nfunction Wn(t, e, n = 0.5) {\n  if (!t && !e) return { r: 0, g: 0, b: 0, a: 1 };\n  if (!t) return O(e);\n  if (!e) return O(t);\n  const r = O(t), o = O(e), i = w(n, 0, 1), s = i * 2 - 1, c = r.a - o.a, f = ((s * c === -1 ? s : (s + c) / (1 + s * c)) + 1) / 2, u = 1 - f;\n  return {\n    r: Math.round(r.r * f + o.r * u),\n    g: Math.round(r.g * f + o.g * u),\n    b: Math.round(r.b * f + o.b * u),\n    a: Math.round(r.a * i + o.a * (1 - i)),\n    format: \"rgba\",\n    toString: S\n  };\n}\nfunction zn(t, e) {\n  const n = O(t);\n  return n.a = C(e), n;\n}\nfunction jn(t = !1, e = \"hex\") {\n  const n = Math.round(Math.random() * 255), r = Math.round(Math.random() * 255), o = Math.round(Math.random() * 255);\n  if (e === \"hex\")\n    return t ? ct(n, r, o, Math.random()) : st(n, r, o);\n  let i;\n  return e === \"hsl\" ? i = Bt(n, r, o) : e === \"hsv\" ? i = Ut(n, r, o) : i = /* @__PURE__ */ Object.create({ r: n, g: r, b: o, toString: S }), t && (i.a = Math.random()), i.toString();\n}\nfunction Yt(t, e = !1, n = \"hex\") {\n  const r = Math.round(Math.random() * 360), o = Math.round(t === \"hard\" ? 80 + Math.random() * 20 : 20 + Math.random() * 70) / 100, i = Math.round(t === \"hard\" ? 40 + Math.random() * 20 : 80 + Math.random() * 15) / 100;\n  if (n === \"hsl\")\n    return H.bind({ h: r, s: o, l: i })();\n  let s;\n  if (n === \"hex\" || n === \"rgb\") {\n    if (s = Pt(r, o, i), n === \"hex\") {\n      const { r: c, g: a, b: f } = s;\n      return e ? ct(c, a, f, Math.random()) : st(c, a, f);\n    }\n  } else n === \"hsv\" && (s = ge(r, o, i));\n  return e && (s.a = Math.random()), s.toString();\n}\nfunction qn(t = !1, e = \"hex\") {\n  return Yt(\"hard\", t, e);\n}\nfunction Kn(t = !1, e = \"hex\") {\n  return Yt(\"soft\", t, e);\n}\nfunction Qn(t) {\n  return Gt(O(t));\n}\nfunction $(t) {\n  return t.length === 1 ? `0${t}` : t.toString();\n}\nfunction T(t) {\n  return t.charAt(0) === t.charAt(1);\n}\nfunction me(t) {\n  return Math.round(parseFloat(t) * 255).toString(16);\n}\nfunction mt(t) {\n  return parseInt(t, 16) / 255;\n}\nfunction w(t, e, n) {\n  return Math.max(e, Math.min(n, parseFloat(t)));\n}\nfunction tt(t, e, n) {\n  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;\n}\nfunction I(t) {\n  return String(t).trim().includes(\"%\");\n}\nfunction L(t) {\n  const e = parseFloat(t) / 100;\n  return Number.isNaN(e) ? 0 : e;\n}\nfunction S() {\n  return M(this.a) && this.a >= 0 && this.a < 1 ? `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})` : `rgb(${this.r}, ${this.g}, ${this.b})`;\n}\nfunction H() {\n  const t = `${this.s * 100}%`, e = `${this.l * 100}%`;\n  return M(this.a) && this.a >= 0 && this.a < 1 ? `hsla(${this.h}, ${t}, ${e}, ${this.a})` : `hsl(${this.h}, ${t}, ${e})`;\n}\nfunction q() {\n  const t = `${this.s * 100}%`, e = `${this.v * 100}%`;\n  return M(this.a) && this.a >= 0 && this.a < 1 ? `hsva(${this.h}, ${t}, ${e}, ${this.a})` : `hsv(${this.h}, ${t}, ${e})`;\n}\nfunction Gt(t) {\n  return (t.r * 0.2126 + t.g * 0.7152 + t.b * 0.0722) / 255;\n}\nlet Wt = 0;\nfunction Xn() {\n  return Wt++;\n}\nfunction Vn(t) {\n  Wt = Math.round(t);\n}\nfunction Zn(t = 0) {\n  return {\n    getCount: () => t++,\n    setCount: (e) => {\n      t = e;\n    }\n  };\n}\nfunction bt(t) {\n  return t & -t;\n}\nfunction Jn(t, e = 0) {\n  const n = new Array(t + 1).fill(0);\n  function r(c, a) {\n    if (!(!a || c >= t))\n      for (c += 1; c <= t; )\n        n[c] += a, c += bt(c);\n  }\n  function o(c = t) {\n    if (c <= 0) return 0;\n    c > t && (c = t);\n    let a = c * e;\n    for (; c > 0; )\n      a += n[c], c -= bt(c);\n    return a;\n  }\n  function i(c) {\n    return o(c + 1) - o(c);\n  }\n  function s(c) {\n    let a = 0, f = t;\n    for (; f > a; ) {\n      const u = Math.floor((a + f) / 2), d = o(u);\n      if (d > c) {\n        f = u;\n        continue;\n      } else if (d < c) {\n        if (a === u)\n          return o(a + 1) <= c ? a + 1 : a;\n        a = u;\n      } else\n        return u;\n    }\n    return a;\n  }\n  return { tree: n, add: r, sum: o, get: i, boundIndex: s };\n}\nconst be = /^\\s*[+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?\\s*$/;\nfunction ye(t, e = !1) {\n  return typeof t == \"number\" ? !Number.isNaN(t) : e ? be.test(String(t)) : !Number.isNaN(parseFloat(t)) || !Number.isNaN(Number(t));\n}\nfunction Me(t) {\n  let e = parseFloat(t);\n  return Number.isNaN(e) && (e = Number(t)), Number.isNaN(e) ? 0 : e;\n}\nfunction Se(t, e) {\n  return e <= 0 ? t.toString() : `${t < 0 ? \"-\" : \"\"}${String(Math.abs(Math.round(t))).padStart(e, \"0\")}`;\n}\nfunction A(t) {\n  return Se(t, 2);\n}\nfunction E(t) {\n  const e = t.toString().split(/[eE]/), n = (e[0].split(\".\")[1] || \"\").length - +(e[1] || 0);\n  return n > 0 ? n : 0;\n}\nfunction vn(t) {\n  return E(t);\n}\nfunction tr(t, e = 3, n = \",\") {\n  if (typeof t != \"number\" && (t = parseFloat(t)), Number.isNaN(t)) return \"0\";\n  let [r, o] = String(t).split(\".\");\n  const i = new RegExp(`(\\\\d+)(\\\\d{${e}})`);\n  for (; i.test(r); )\n    r = r.replace(i, `$1${n}$2`);\n  return o = o ? `.${o}` : \"\", `${r}${o}`;\n}\nfunction zt(t, e) {\n  e = Math.max(Math.round(e), 0);\n  let n = t.toFixed(E(t));\n  const r = n.indexOf(\".\");\n  if (r === -1) return t;\n  const o = n.replace(\".\", \"\").split(\"\"), i = r + e;\n  return o[i] ? (n.charAt(i + 1) === \"5\" ? n = n.substring(0, i + 1) + \"6\" : n = n.substring(0, i + 2), parseFloat(Number(n).toFixed(e))) : t;\n}\nfunction er(t, e, n) {\n  return zt(t * e, n);\n}\nfunction nr(t, e) {\n  if (e < 0 || e > 1)\n    return Math.round(t);\n  const n = Math.ceil(t);\n  return t + 1 - e >= n ? n : Math.floor(t);\n}\nfunction rr(t, e, n) {\n  return Math.max(e, Math.min(n, parseFloat(t)));\n}\nfunction or(t, e, n = 0) {\n  if (t <= 0 || e <= 1) return [t];\n  n < 1 && (n = 1 / 0);\n  const r = [];\n  let o = 0;\n  for (; t >= e && o < n; )\n    r.push(t % e), t = Math.floor(t / e), ++o;\n  return r.push(t), r.reverse();\n}\nconst et = [\"th\", \"st\", \"nd\", \"rd\"];\nfunction ir(t) {\n  if (t = Math.round(t), t <= 0) return `${t}th`;\n  const e = t % 100 > 10 && t % 100 < 14 ? et[0] : et[t % 10] || et[0];\n  return `${t}${e}`;\n}\nconst yt = Object.freeze([\n  \"B\",\n  \"KB\",\n  \"MB\",\n  \"GB\",\n  \"TB\",\n  \"AUTO\"\n]);\nfunction sr(t, e = \"AUTO\", n = !1, r) {\n  typeof r > \"u\" && (typeof n == \"number\" ? (r = n, n = !1) : r = 2);\n  let o = e.toUpperCase();\n  o = yt.includes(o) ? o : \"AUTO\";\n  let i;\n  switch (o) {\n    case \"AUTO\":\n      i = 0;\n      break;\n    case \"KB\":\n      i = 1;\n      break;\n    case \"MB\":\n      i = 2;\n      break;\n    case \"GB\":\n      i = 3;\n      break;\n    case \"TB\":\n      i = 4;\n      break;\n    default:\n      return t;\n  }\n  let s;\n  if (i)\n    s = t / 1024 ** i;\n  else\n    for (s = t; s > 1024 && !(i > 4); ++i)\n      s = s / 1024;\n  return s = zt(s, r), n ? `${s}${o === \"AUTO\" ? yt[Math.min(i, 4)] : o}` : s;\n}\nfunction cr(t, e = 0) {\n  return e === t ? e : (e > t && ([e, t] = [t, e]), Math.random() * (t - e) + e);\n}\nfunction jt(t, e = 15) {\n  return +parseFloat(Number(t).toPrecision(e));\n}\nfunction K(t) {\n  const e = String(t);\n  if (!e.includes(\"e\"))\n    return Number(e.replace(\".\", \"\"));\n  const n = E(t);\n  return n > 0 ? jt(Number(t) * 10 ** n) : Number(t);\n}\nfunction Q(t) {\n  return (...e) => {\n    let n = e[0];\n    for (let r = 1, o = e.length; r < o; ++r)\n      n = t(n, e[r]);\n    return n;\n  };\n}\nconst P = Q((t, e) => {\n  const n = K(t), r = K(e), o = E(t) + E(e);\n  return n * r / 10 ** o;\n}), ar = Q((t, e) => {\n  const n = 10 ** Math.max(E(t), E(e));\n  return (P(t, n) + P(e, n)) / n;\n}), fr = Q((t, e) => {\n  const n = 10 ** Math.max(E(t), E(e));\n  return (P(t, n) - P(e, n)) / n;\n}), ur = Q((t, e) => {\n  const n = K(t), r = K(e);\n  return P(n / r, jt(10 ** (E(e) - E(t))));\n}), we = 1e3, N = 1e3, k = 60, Ee = k * N, lr = k * N, X = 60, qt = X * k, Ae = qt * N, dr = qt * N, Kt = 24, Ne = Kt * X, Qt = Ne * k, Fe = Qt * N, hr = Qt * N, at = 7, Oe = at * Kt, $e = Oe * X, Xt = $e * k, Te = Xt * N, gr = Xt * N, Vt = 3, Ce = 4, Re = Ce * Vt, _e = {\n  y(t, e) {\n    const n = t.getFullYear();\n    return e.length === 4 ? n : n % 1e3 % 100;\n  },\n  M(t, e) {\n    const n = t.getMonth() + 1;\n    return e.length === 2 ? A(n) : n;\n  },\n  d(t, e) {\n    const n = t.getDate();\n    return e.length === 2 ? A(n) : n;\n  },\n  H(t, e) {\n    const n = t.getHours();\n    return e.length === 2 ? A(n) : n;\n  },\n  m(t, e) {\n    const n = t.getMinutes();\n    return e.length === 2 ? A(n) : n;\n  },\n  s(t, e) {\n    const n = t.getSeconds();\n    return e.length === 2 ? A(n) : n;\n  },\n  q(t, e) {\n    const n = Math.ceil((t.getMonth() + 1) / 3);\n    return e.length === 2 ? A(n) : n;\n  }\n}, ke = /[yMdHmsq](\\w)*|./g, xe = /'(.+?)'/g;\nfunction h(t, e = !1) {\n  const n = new Date(t);\n  if (e && Number.isNaN(+n))\n    throw new RangeError(\"Invalid date value\");\n  return typeof t == \"string\" && !t.includes(\":\") && (n.setHours(0), n.setMinutes(0), n.setSeconds(0)), n;\n}\nfunction pr(t, e = \"yyyy-MM-dd HH:mm:ss\") {\n  t = h(t);\n  const n = e.match(ke), r = n == null ? void 0 : n.length;\n  if (!r)\n    return e;\n  let o = 0, i = \"\";\n  for (; o < r; ) {\n    const s = n[o], c = s[0], a = _e[c];\n    a ? i += a(t, s) : i += s, ++o;\n  }\n  return i.replace(xe, \"$1\");\n}\nfunction mr(t) {\n  return t = h(t), `${A(t.getHours())}:${A(t.getMinutes())}:${A(\n    t.getSeconds()\n  )}`;\n}\nfunction ot(t) {\n  return t = h(t), Math.floor(t.getMonth() / 3) + 1;\n}\nconst De = [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"];\nfunction br(t) {\n  return De[t.getDay()];\n}\nfunction Ie(t, e) {\n  return t = h(t), t.setTime(t.getTime() + e), t;\n}\nfunction Le(t, e) {\n  return e *= N, Ie(t, e);\n}\nfunction He(t, e) {\n  return e *= k, Le(t, e);\n}\nfunction Pe(t, e) {\n  return e *= X, He(t, e);\n}\nfunction yr(t, e) {\n  return e *= 12, Pe(t, e);\n}\nfunction ft(t, e) {\n  return t = h(t), e = ~~e, t.setDate(t.getDate() + e), t;\n}\nfunction Mr(t, e) {\n  return e *= at, ft(t, e);\n}\nfunction ut(t, e) {\n  return t = h(t), e = ~~e, t.setMonth(t.getMonth() + e), t;\n}\nfunction Sr(t, e) {\n  return e *= Vt, ut(t, e);\n}\nfunction wr(t, e) {\n  return e *= Re, ut(t, e);\n}\nfunction Er(t, e = 42, n = 1) {\n  t = h(t);\n  const r = [];\n  for (let o = 0; o < e; ++o)\n    r.push(ft(t, o * n));\n  return r;\n}\nfunction Ar(t, e = 12, n = 1) {\n  t = h(t);\n  const r = [];\n  for (let o = 0; o < e; ++o)\n    r.push(ut(t, o * n));\n  return r;\n}\nfunction Nr(t) {\n  const e = t.getDay() ?? 7;\n  return ft(t, -e);\n}\nfunction Mt(t) {\n  return t = h(t), t.setMilliseconds(0), t;\n}\nfunction St(t) {\n  return t = h(t), t.setSeconds(0, 0), t;\n}\nfunction wt(t) {\n  return t = h(t), t.setMinutes(0, 0, 0), t;\n}\nfunction Et(t) {\n  return t = h(t), t.setHours(0, 0, 0, 0), t;\n}\nfunction Fr(t) {\n  return t = h(t), t.setHours(23, 59, 59, 999), t;\n}\nfunction At(t, e = 0) {\n  e = e % 7, e < 0 && (e += 7), t = h(t);\n  const n = t.getDay(), r = (n < e ? 7 : 0) + n - e;\n  return t.setDate(t.getDate() - r), t.setHours(0, 0, 0, 0), t;\n}\nfunction Be(t) {\n  return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0;\n}\nfunction Ue(t, e) {\n  let n;\n  return e < 7 ? e !== 2 ? n = 30 + e % 2 : Be(t) ? n = 29 : n = 28 : n = 31 - e % 2, n;\n}\nfunction Or(t, e = 1) {\n  t = h(t);\n  const n = t.getFullYear(), r = t.getMonth() + 1, o = t.getDate(), i = Ue(n, r);\n  return e = e % i, e < 0 && (e += i), o < e && t.setMonth(r - 1), t.setDate(e), t.setHours(0, 0, 0, 0), t;\n}\nfunction $r(t) {\n  t = h(t);\n  const e = ot(t);\n  return t.setDate(1), t.setHours(0, 0, 0, 0), t.setMonth((e - 1) * 3), t;\n}\nfunction Tr(t, e = 0) {\n  e = e % 11, e < 0 && (e += 11), t = h(t);\n  const n = t.getMonth(), r = (n < e ? 11 : 0) + n - e;\n  return t.setMonth(t.getMonth() - r), t.setDate(1), t.setHours(0, 0, 0, 0), t;\n}\nfunction lt(t, e) {\n  return t = h(t), e = h(e), e.getTime() - t.getTime();\n}\nfunction Ye(t, e) {\n  const n = lt(t, e) / we;\n  return n > 0 ? Math.floor(n) : Math.ceil(n);\n}\nfunction Ge(t, e) {\n  const n = lt(t, e) / Ee;\n  return n > 0 ? Math.floor(n) : Math.ceil(n);\n}\nfunction We(t, e) {\n  const n = lt(t, e) / Ae;\n  return n > 0 ? Math.floor(n) : Math.ceil(n);\n}\nfunction ze(t, e) {\n  return t = Et(t), e = Et(e), (e.getTime() - t.getTime()) / Fe;\n}\nfunction Cr(t, e, n = 0) {\n  return t = At(t, n), e = At(e, n), (e.getTime() - t.getTime()) / Te;\n}\nfunction je(t, e) {\n  t = h(t), e = h(e);\n  const n = e.getFullYear() - t.getFullYear(), r = e.getMonth() - t.getMonth();\n  return n * 12 + r;\n}\nfunction Rr(t, e) {\n  t = h(t), e = h(e);\n  const n = e.getFullYear() - t.getFullYear(), r = ot(e) - ot(t);\n  return n * 4 + r;\n}\nfunction qe(t, e) {\n  return t = h(t), e = h(e), e.getFullYear() - t.getFullYear();\n}\nfunction Ke(t, e) {\n  t = h(t), e = h(e);\n  const n = t.getTime() - e.getTime();\n  return n < 0 ? -1 : n > 0 ? 1 : n;\n}\nfunction _(t, e) {\n  return -Ke(t, e);\n}\nfunction _r(t, e) {\n  return t = Mt(t), e = Mt(e), Ye(t, e);\n}\nfunction kr(t, e) {\n  return t = St(t), e = St(e), Ge(t, e);\n}\nfunction xr(t, e) {\n  return t = wt(t), e = wt(e), We(t, e);\n}\nfunction Qe(t, e) {\n  const n = _(t, e), r = Math.abs(ze(t, e));\n  t = h(t), t.setDate(t.getDate() + n * r);\n  const o = _(t, e) === -n;\n  return n * (r - (o ? 1 : 0));\n}\nfunction Dr(t, e) {\n  const n = Qe(t, e) / at;\n  return n > 0 ? Math.floor(n) : Math.ceil(n);\n}\nfunction Xe(t, e) {\n  const n = _(t, e), r = Math.abs(je(t, e));\n  t = h(t), t.setMonth(t.getMonth() + n * r);\n  const o = _(t, e) === -n;\n  return n * (r - (o ? 1 : 0));\n}\nfunction Ir(t, e) {\n  const n = Xe(t, e) / 3;\n  return n > 0 ? Math.floor(n) : Math.ceil(n);\n}\nfunction Lr(t, e) {\n  const n = _(t, e), r = Math.abs(qe(t, e));\n  t = h(t), t.setFullYear(t.getFullYear() + n * r);\n  const o = _(t, e) === -n;\n  return n * (r - (o ? 1 : 0));\n}\nfunction Ve(t, e = {}) {\n  if (t == null || typeof t != \"object\")\n    return t;\n  const { cloneObject: n = it } = e, r = /* @__PURE__ */ Object.create(null), o = [\n    {\n      parent: r,\n      prop: \"root\",\n      data: t\n    }\n  ], i = /* @__PURE__ */ new WeakMap(), s = [], c = [];\n  for (; o.length; ) {\n    const { parent: a, prop: f, data: u } = o.pop();\n    if (!a) continue;\n    const d = ae(u);\n    if (d === \"Date\") {\n      a[f] = new Date(u);\n      continue;\n    }\n    if (d !== \"Array\") {\n      const l = n(d, u);\n      if (l != null) {\n        a[f] = l;\n        continue;\n      }\n    }\n    const g = a[f] = d === \"Array\" || d === \"Set\" || d === \"Map\" ? [] : /* @__PURE__ */ Object.create(null);\n    if (d === \"Set\" || d === \"Map\") {\n      let l = 0;\n      if (d === \"Set\") {\n        for (const p of u)\n          i.has(p) ? g[l] = i.get(p) : p !== null && typeof p == \"object\" ? o.push({\n            parent: g,\n            prop: l,\n            data: p\n          }) : g[l] = p, ++l;\n        s.push({ parent: a, prop: f });\n      } else {\n        for (const p of u) {\n          const b = [];\n          l = 0;\n          for (const m of p)\n            i.has(m) ? b[l] = i.get(m) : m !== null && typeof m == \"object\" ? o.push({\n              parent: b,\n              prop: l,\n              data: m\n            }) : b[l] = m, ++l;\n          g.push(b);\n        }\n        c.push({ parent: a, prop: f });\n      }\n    } else\n      for (const l of Object.keys(u)) {\n        const p = u[l];\n        i.has(p) ? g[l] = i.get(p) : p !== null && typeof p == \"object\" ? o.push({\n          parent: g,\n          prop: l,\n          data: p\n        }) : g[l] = p;\n      }\n    i.set(u, g);\n  }\n  for (const { parent: a, prop: f } of s)\n    a[f] = new Set(a[f]);\n  for (const { parent: a, prop: f } of c)\n    a[f] = new Map(a[f]);\n  return r.root;\n}\nconst Ze = \"This object was destroyed, do not use it anywhere\", Je = () => !0;\nfunction Hr(t, e = Ze) {\n  const n = () => {\n    throw new Error(e);\n  };\n  Object.keys(t).forEach((r) => {\n    typeof t[r] == \"function\" ? t[r] = n.bind(t) : t[r] = null;\n  }), Object.getOwnPropertyNames(t.constructor.prototype).forEach((r) => {\n    r !== \"constructor\" && typeof t[r] == \"function\" && (t[r] = n.bind(t));\n  }), t.isDestroyed = Je;\n}\nconst ve = y && (\"ontouchstart\" in window || tn() > 0), Pr = ve ? \"pointerdown\" : \"click\";\nfunction tn() {\n  return typeof navigator < \"u\" && (navigator.maxTouchPoints || navigator.msMaxTouchPoints) || 0;\n}\nfunction Br(t, e, n = window.Event) {\n  const { type: r, bubbles: o = !1, cancelable: i = !1, ...s } = e;\n  if (!M(r) || r === \"\") return !1;\n  let c;\n  return M(n) ? c = new n(r, { bubbles: o, cancelable: i }) : (c = document.createEvent(\"HTMLEvents\"), c.initEvent(r, o, i)), Object.assign(c, s), t.dispatchEvent(c);\n}\nconst en = [\n  \"button\",\n  \"[href]:not(.disabled)\",\n  \"input\",\n  \"select\",\n  \"textarea\",\n  \"[tabindex]\",\n  \"[contenteditable]\"\n].map((t) => `${t}:not(:disabled):not([disabled])`).join(\", \");\nfunction V(t) {\n  return !!t && t.nodeType === 1;\n}\nfunction nn(t) {\n  return V(t) ? t : document.body;\n}\nfunction rn(t, e) {\n  return !y || !t ? [] : Array.from(nn(e).querySelectorAll(t));\n}\nfunction Ur(t) {\n  if (!y) return !1;\n  const e = document.activeElement;\n  return !V(t) || !e ? !1 : t === e || Zt(e, t);\n}\nfunction Zt(t, e) {\n  if (!t || !e) return !1;\n  const n = e.__transferElement;\n  return e.contains(t) || !!n && (n === t || n.contains(t));\n}\nfunction on(t) {\n  if (!y || !V(t) || !t.parentNode || !Zt(t, document.body) || t.style.display === \"none\")\n    return !0;\n  const e = t.getBoundingClientRect();\n  return !(e && e.width > 0 && e.height > 0);\n}\nfunction sn(t) {\n  return !on(t);\n}\nfunction cn(t) {\n  return !V(t) || t.hasAttribute(\"disabled\") && t.getAttribute(\"disabled\") !== \"false\" || t.disabled;\n}\nfunction Yr(t, e = !1) {\n  const n = e ? () => !1 : cn;\n  return rn(en, t).filter(\n    (r) => sn(r) && r.tabIndex > -1 && !n(r)\n  );\n}\nfunction an(t) {\n  if (!y || !t) return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.paddingLeft) + parseFloat(e.paddingRight) || 0;\n}\nfunction Gr(t) {\n  if (!y || !t) return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.paddingTop) + parseFloat(e.paddingBottom) || 0;\n}\nfunction Wr(t) {\n  if (!y || !t) return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.marginLeft) + parseFloat(e.marginRight) || 0;\n}\nfunction zr(t) {\n  if (!y || !t) return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.marginTop) + parseFloat(e.marginBottom) || 0;\n}\nfunction jr(t) {\n  if (!y || !t) return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.borderLeftWidth) + parseFloat(e.borderRightWidth) || 0;\n}\nfunction qr(t) {\n  if (!y || !t) return 0;\n  const e = getComputedStyle(t);\n  return parseFloat(e.borderTopWidth) + parseFloat(e.borderBottomWidth) || 0;\n}\nfunction Kr(t) {\n  if (!y || !t) return 0;\n  const e = document.createRange();\n  e.setStart(t, 0), e.setEnd(t, t.childNodes.length);\n  const n = e.getBoundingClientRect().width, r = an(t);\n  return n + r;\n}\nfunction Qr(t) {\n  return ye(t, !0) ? `${Me(t)}px` : String(t).trim();\n}\nfunction Xr(t) {\n  return M(t) && t !== !1 ? String(t) : void 0;\n}\nconst fn = /[\"'&<>]/;\nfunction Vr(t) {\n  const e = \"\" + t, n = fn.exec(e);\n  if (!n)\n    return e;\n  let r = \"\", o, i, s = 0;\n  for (i = n.index; i < e.length; i++) {\n    switch (e.charCodeAt(i)) {\n      case 34:\n        o = \"&quot;\";\n        break;\n      case 38:\n        o = \"&amp;\";\n        break;\n      case 39:\n        o = \"&#39;\";\n        break;\n      case 60:\n        o = \"&lt;\";\n        break;\n      case 62:\n        o = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    s !== i && (r += e.substring(s, i)), s = i + 1, r += o;\n  }\n  return s !== i ? r + e.substring(s, i) : r;\n}\nfunction Zr() {\n  const t = /* @__PURE__ */ new Map();\n  return {\n    on(e, n) {\n      const r = t.get(e);\n      (r == null ? void 0 : r.add(n)) || t.set(e, /* @__PURE__ */ new Set([n]));\n    },\n    off(e, n) {\n      const r = t.get(e);\n      r && r.delete(n);\n    },\n    clear(e) {\n      const n = t.get(e);\n      n && n.clear();\n    },\n    clearAll() {\n      t.clear();\n    },\n    emit(e, ...n) {\n      const r = t.get(e);\n      r && r.forEach((o) => {\n        o(...n);\n      });\n    }\n  };\n}\nfunction dt(t, e, n) {\n  t && !e.has(t) && (n(t), e.add(t));\n}\nconst un = /* @__PURE__ */ new Set();\nfunction Jr(t, e = console.info) {\n  dt(t, un, e);\n}\nconst ln = /* @__PURE__ */ new Set();\nfunction vr(t, e = console.warn) {\n  dt(t, ln, e);\n}\nconst dn = /* @__PURE__ */ new Set();\nfunction to(t, e = console.warn) {\n  dt(t, dn, e);\n}\nconst ht = y ? requestAnimationFrame : (t) => {\n  setTimeout(t, 16);\n};\nfunction eo(t, e = 16) {\n  if (typeof t != \"function\")\n    return it;\n  const n = (...i) => {\n    t(...i);\n  };\n  if (e <= 0)\n    return Jt(n);\n  let r = 0, o;\n  return function(...i) {\n    const s = Date.now(), c = s - r;\n    clearTimeout(o), c >= e ? (r = s, n(...i)) : o = setTimeout(\n      () => {\n        r = Date.now(), n(...i);\n      },\n      Math.max(0, e - c)\n    );\n  };\n}\nfunction no(t, e = 100) {\n  if (typeof t != \"function\")\n    return it;\n  const n = (...o) => {\n    t(...o);\n  };\n  if (e <= 0)\n    return Jt(n);\n  let r;\n  return function(...o) {\n    clearTimeout(r), r = setTimeout(() => {\n      n(...o);\n    }, e);\n  };\n}\nfunction Jt(t) {\n  if (typeof t != \"function\")\n    return t;\n  let e = !1, n, r;\n  return function(...o) {\n    return n = o, e || (e = !0, r = Promise.resolve().then(() => (e = !1, r = void 0, t(...n)))), r;\n  };\n}\nfunction ro(t) {\n  if (typeof t != \"function\")\n    return t;\n  let e = !1, n, r;\n  return function(...o) {\n    return n = o, e || (e = !0, r = new Promise(\n      (i) => ht(() => {\n        e = !1, r = void 0, i(t(...n));\n      })\n    )), r;\n  };\n}\nconst x = /* @__PURE__ */ new Set(), vt = /* @__PURE__ */ new WeakMap();\nfunction hn() {\n  x.forEach((t) => {\n    t(...vt.get(t));\n  }), x.clear();\n}\nfunction oo(t, ...e) {\n  if (typeof t != \"function\")\n    return t;\n  vt.set(t, e), !x.has(t) && (x.add(t), x.size === 1 && Promise.resolve().then(hn));\n}\nconst D = /* @__PURE__ */ new Set(), te = /* @__PURE__ */ new WeakMap();\nfunction gn() {\n  D.forEach((t) => {\n    t(...te.get(t));\n  }), D.clear();\n}\nfunction io(t, ...e) {\n  if (typeof t != \"function\")\n    return t;\n  te.set(t, e), !D.has(t) && (D.add(t), D.size === 1 && ht(gn));\n}\nasync function so(t, e, n) {\n  const r = [], o = [];\n  for (const i of e) {\n    const s = Promise.resolve().then(() => n(i, e));\n    if (r.push(s), t <= e.length) {\n      const c = s.then(() => o.splice(o.indexOf(c), 1));\n      o.push(c), o.length >= t && await Promise.race(o);\n    }\n  }\n  return Promise.all(r);\n}\nlet nt = null;\nfunction co() {\n  if (!y)\n    return !0;\n  if (nt === null) {\n    const t = document.createElement(\"div\");\n    t.style.display = \"flex\", t.style.flexDirection = \"column\", t.style.rowGap = \"1px\", t.appendChild(document.createElement(\"div\")), t.appendChild(document.createElement(\"div\")), document.body.appendChild(t), nt = t.scrollHeight === 1, document.body.removeChild(t);\n  }\n  return nt;\n}\nlet rt = null;\nfunction ao() {\n  return y ? (rt === null && (rt = \"loading\" in document.createElement(\"img\")), rt) : !1;\n}\nfunction fo(t) {\n  return Array.isArray(t) ? t : [t];\n}\nfunction uo(t, ...e) {\n  return $t(t) ? t(...e) : t;\n}\nfunction lo(t) {\n  return t.replace(/[\\\\/]+/g, \"/\");\n}\nfunction ho(t) {\n  return t[t.length - 1];\n}\nconst Nt = (t) => t;\nfunction go(t, e, n, r) {\n  let o;\n  typeof n != \"function\" && r === void 0 ? (r = !!n, o = Nt) : o = typeof n == \"function\" ? n : Nt;\n  const i = r ? /* @__PURE__ */ new Map() : {};\n  if (!M(e)) return i;\n  const s = r ? (a, f) => i.set(a, f) : (a, f) => i[a] = f, c = $t(e) ? e : (a) => a[e];\n  return t.forEach((a) => {\n    if (!M(a)) return;\n    const f = c(a);\n    M(f) && s(f, o(a));\n  }), i;\n}\nfunction po(t, e, n = !1) {\n  let r = -1;\n  return n || typeof e != \"function\" ? r = t.findIndex((o) => o === e) : r = t.findIndex(e), ~r ? t.splice(r, 1)[0] : null;\n}\nfunction mo(t, e = []) {\n  (typeof e == \"string\" || typeof e == \"function\") && (e = [e]);\n  const n = e.length, r = {};\n  for (const o of t) {\n    let i;\n    for (let s = 0; s < n; ++s) {\n      const c = s === n - 1, a = e[s], f = typeof a == \"function\" ? a(o) : o[a];\n      i ? (i[f] || (i[f] = c ? [] : {}), i = i[f]) : (r[f] || (r[f] = c ? [] : {}), i = r[f]);\n    }\n    i.push(o);\n  }\n  return r;\n}\nfunction bo(t, e = {}) {\n  const {\n    keyField: n = \"id\",\n    childField: r = \"children\",\n    parentField: o = \"parent\",\n    rootId: i = null\n  } = e, s = M(i) && i !== \"\", c = [], a = /* @__PURE__ */ new Map();\n  for (let f = 0, u = t.length; f < u; ++f) {\n    const d = t[f], g = d[n];\n    if (!(s ? g === i : !M(g)))\n      if (a.has(g) ? d[r] = a.get(g) : (d[r] = [], a.set(g, d[r])), d[o] && (!s || d[o] !== i)) {\n        const l = d[o];\n        a.has(l) || a.set(l, []), a.get(l).push(d);\n      } else\n        c.push(d);\n  }\n  return c;\n}\nfunction yo(t, e = {}) {\n  const {\n    keyField: n = \"id\",\n    childField: r = \"children\",\n    parentField: o = \"parent\",\n    rootId: i = null,\n    depthFirst: s = !1,\n    injectId: c = !0,\n    buildId: a = (m) => m,\n    filter: f = ce,\n    cascaded: u = !1,\n    forceInject: d = !1\n  } = e;\n  let g = 1;\n  const l = M(i) && i !== \"\", p = [], b = [...t];\n  for (; b.length; ) {\n    const m = b.shift(), Z = m[r], J = Array.isArray(Z) && Z.length ? Z : [];\n    c && (d || !m[n]) && (m[n] = a(g++));\n    const ee = m[n];\n    c && o && (l ? m[o] === i : !m[o]) && (m[o] = i);\n    const gt = f(m);\n    if (gt && p.push(m), gt || !u) {\n      for (let v = 0, ne = J.length; v < ne; ++v) {\n        const pt = J[v];\n        c && o && (pt[o] = ee), !s && b.push(pt);\n      }\n      s && b.unshift(...J);\n    }\n  }\n  return p;\n}\nfunction Mo(t, e, n = {}) {\n  const { childField: r = \"children\", depthFirst: o = !1 } = n, i = [...t.map((s) => ({ item: s, depth: 0, parent: null }))];\n  for (; i.length; ) {\n    const { item: s, depth: c, parent: a } = i.shift(), f = s[r];\n    e(s, c, a), G(f) && i[o ? \"unshift\" : \"push\"](\n      ...Array.from(f).map((u) => ({ item: u, depth: c + 1, parent: s }))\n    );\n  }\n}\nfunction So(t, e, n = {}) {\n  const { childField: r = \"children\", depthFirst: o = !1, clearChildren: i = !0 } = n, s = [], c = [...t.map((a) => ({ item: a, depth: 0, parent: null, result: s }))];\n  for (; c.length; ) {\n    const { item: a, depth: f, parent: u, result: d } = c.shift(), g = a[r], l = e(a, f, u) ?? {};\n    i && (l[r] = []), d.push(l), G(g) && Array.from(g).length && (l[r] = [], c[o ? \"unshift\" : \"push\"](\n      ...Array.from(g).map((b) => ({\n        item: b,\n        depth: f + 1,\n        parent: a,\n        result: l[r]\n      }))\n    ));\n  }\n  return s;\n}\nfunction wo(t, e, n = {}) {\n  const {\n    childField: r = \"children\",\n    leafOnly: o = !1,\n    isLeaf: i = (c) => !G(c[r])\n  } = n, s = (c, a, f) => c.map((u) => ({ ...u })).filter((u) => {\n    const d = u[r], g = i(u), l = G(d) && Array.from(d);\n    if (o && !g) {\n      if (l && l.length) {\n        const b = s(l, a + 1, u);\n        return u[r] = b, !!b.length;\n      }\n      return !1;\n    }\n    const p = e(u, a, f);\n    if (g) return p;\n    if (!o && p) return !0;\n    if (l && l.length) {\n      const b = s(l, a + 1, u);\n      return u[r] = b, !!b.length;\n    }\n    return p;\n  });\n  return s(t, 0, null);\n}\nconst Ft = (t, e) => Number.isNaN(Number(t) - Number(e)) ? String(t).localeCompare(e) : t - e;\nfunction Eo(t, e) {\n  if (!t.sort || Y(e) && !e.key || !e.length)\n    return t;\n  const n = Array.from(t);\n  Array.isArray(e) || (e = [e]);\n  const r = e.map(\n    (o) => typeof o == \"string\" ? {\n      key: o,\n      method: Ft,\n      type: \"asc\"\n    } : o\n  ).map((o) => (typeof o.accessor != \"function\" && (o.accessor = (i) => i[o.key]), typeof o.method != \"function\" && (o.method = Ft), o.params = Array.isArray(o.params) ? o.params : [], o));\n  return n.sort((o, i) => {\n    let s = 0;\n    for (const c of r) {\n      const { method: a, type: f, accessor: u, params: d } = c, g = f === \"desc\", l = a(u(o, ...d), u(i, ...d));\n      if (s = g ? -l : l, s) break;\n    }\n    return s;\n  }), n;\n}\nfunction Ao(t, e, n = !0) {\n  t = n ? Ve(t) : t;\n  const r = [\n    {\n      source: t,\n      target: e\n    }\n  ];\n  for (; r.length; ) {\n    const { source: o, target: i } = r.pop();\n    Object.keys(i).forEach((s) => {\n      Y(i[s]) ? (Y(o[s]) || (o[s] = /* @__PURE__ */ Object.create(null)), r.push({\n        source: o[s],\n        target: i[s]\n      })) : Array.isArray(i[s]) ? (Array.isArray(o[s]) || (o[s] = []), r.push({\n        source: o[s],\n        target: i[s]\n      })) : o[s] = i[s];\n    });\n  }\n  return t;\n}\nfunction No(t) {\n  t = Array.from(t);\n  let e = !1;\n  const n = () => {\n    var r;\n    e || ((r = t.shift()) == null || r(), t.length && ht(n));\n  };\n  return n(), () => e = !0;\n}\nfunction pn(t) {\n  const e = t.match(/[A-Z]+/);\n  return e && e[0] === t;\n}\nconst mn = /\\B([A-Z])(?=[^A-Z_-])/g;\nfunction Fo(t) {\n  return t.replace(mn, \"-$1\").toLowerCase();\n}\nfunction bn(t) {\n  return t = t.trim().replace(/\\s+/g, \"-\"), t = t.replace(/-+(\\w)/g, (e, n) => n ? n.toUpperCase() : \"\"), (t.charAt(0).toLocaleUpperCase() + t.slice(1)).replace(\n    /[^\\w]/g,\n    \"\"\n  );\n}\nfunction Oo(t) {\n  const e = bn(t);\n  return pn(e) ? e.toLocaleLowerCase() : e.charAt(0).toLowerCase() + e.slice(1);\n}\nexport {\n  Pr as CLICK_TYPE,\n  de as COLOR_NAMES,\n  Kt as DAY_ON_HOURS,\n  hr as DAY_ON_MILLISECONDS,\n  Fe as DAY_ON_MILLS,\n  Ne as DAY_ON_MINUTES,\n  Qt as DAY_ON_SECONDS,\n  Dt as HEX_REG_3,\n  It as HEX_REG_4,\n  Lt as HEX_REG_6,\n  Ht as HEX_REG_8,\n  dr as HOUR_ON_MILLISECONDS,\n  Ae as HOUR_ON_MILLS,\n  X as HOUR_ON_MINUTES,\n  qt as HOUR_ON_SECONDS,\n  _t as HSLA_REG,\n  Rt as HSL_REG,\n  xt as HSVA_REG,\n  kt as HSV_REG,\n  lr as MINUTE_ON_MILLISECONDS,\n  Ee as MINUTE_ON_MILLS,\n  k as MINUTE_ON_SECONDS,\n  W as NAMED_COLORS,\n  Vt as QUARTER_ON_MONTHS,\n  Ct as RGBA_REG,\n  Tt as RGB_REG,\n  N as SECOND_ON_MILLISECONDS,\n  we as SECOND_ON_MILLS,\n  ve as USE_TOUCH,\n  at as WEEK_ON_DAYS,\n  Oe as WEEK_ON_HOURS,\n  gr as WEEK_ON_MILLISECONDS,\n  Te as WEEK_ON_MILLS,\n  $e as WEEK_ON_MINUTES,\n  Xt as WEEK_ON_SECONDS,\n  Re as YEAR_ON_MONTHS,\n  Ce as YEAR_ON_QUARTERS,\n  ft as addDays,\n  yr as addHalfDays,\n  Pe as addHours,\n  Ie as addMilliseconds,\n  He as addMinutes,\n  ut as addMonths,\n  Sr as addQuarters,\n  Le as addSeconds,\n  Mr as addWeeks,\n  wr as addYears,\n  zn as adjustAlpha,\n  rr as boundRange,\n  bo as buildTree,\n  uo as callIfFunc,\n  Ke as compareAsc,\n  _ as compareDesc,\n  Zt as contains,\n  Jn as createBITree,\n  Zn as createCounter,\n  Zr as createEventEmitter,\n  no as debounce,\n  ro as debounceFrame,\n  Jt as debounceMinor,\n  Pn as decide,\n  E as decimalLength,\n  Ve as deepClone,\n  Hr as destroyObject,\n  ze as differenceDays,\n  Qe as differenceFullDays,\n  xr as differenceFullHours,\n  kr as differenceFullMinutes,\n  Xe as differenceFullMonths,\n  Ir as differenceFullQuarters,\n  _r as differenceFullSeconds,\n  Dr as differenceFullWeeks,\n  Lr as differenceFullYears,\n  We as differenceHours,\n  lt as differenceMilliseconds,\n  Ge as differenceMinutes,\n  je as differenceMonths,\n  Rr as differenceQuarters,\n  Ye as differenceSeconds,\n  Cr as differenceWeeks,\n  qe as differenceYears,\n  vn as digitLength,\n  Br as dispatchEvent,\n  ur as divide,\n  A as doubleDigits,\n  Fr as endOfDay,\n  fo as ensureArray,\n  to as errorOnce,\n  Vr as escapeHtml,\n  wo as filterTree,\n  yo as flatTree,\n  pr as format,\n  sr as formatByteSize,\n  br as getChineseWeek,\n  Xn as getGlobalCount,\n  ho as getLast,\n  Ue as getLastDayOfMonth,\n  Nr as getLastSunday,\n  ot as getQuarter,\n  Kr as getRangeWidth,\n  mr as getTime,\n  ae as getType,\n  jr as getXBorder,\n  Wr as getXMargin,\n  an as getXPadding,\n  qr as getYBorder,\n  zr as getYMargin,\n  Gr as getYPadding,\n  mo as groupByProps,\n  Mn as has,\n  ge as hslToHsv,\n  Pt as hslToRgb,\n  Gn as hsvToHsl,\n  pe as hsvToRgb,\n  Jr as infoOnce,\n  B as is,\n  $n as isArray,\n  On as isBigInt,\n  En as isBoolean,\n  y as isClient,\n  Un as isColor,\n  _n as isDate,\n  M as isDefined,\n  cn as isDisabled,\n  Dn as isElement,\n  xn as isEmpty,\n  Nn as isFalse,\n  Ur as isFocusIn,\n  $t as isFunction,\n  on as isHidden,\n  yn as isIOS,\n  G as isIterable,\n  Be as isLeapYear,\n  Rn as isMap,\n  se as isNaN,\n  ie as isNull,\n  Sn as isNumber,\n  Y as isObject,\n  Tn as isPromise,\n  kn as isRegExp,\n  Cn as isSet,\n  wn as isString,\n  Fn as isSymbol,\n  An as isTrue,\n  ye as isValidNumber,\n  sn as isVisible,\n  or as leaveNumber,\n  go as listToMap,\n  So as mapTree,\n  Ao as mergeObjects,\n  fr as minus,\n  Wn as mixColor,\n  er as multipleFixed,\n  io as nextFrameOnce,\n  oo as nextTickOnce,\n  it as noop,\n  C as normalizeAlpha,\n  z as normalizeHsl,\n  j as normalizeHsv,\n  lo as normalizePath,\n  R as normalizeRgb,\n  be as numberRE,\n  ir as ordinalNumber,\n  Se as padStartZeros,\n  Yn as parseColor,\n  O as parseColorToRgba,\n  he as parseStringColor,\n  ar as plus,\n  rn as queryAll,\n  Yr as queryTabables,\n  ht as raf,\n  cr as random,\n  jn as randomColor,\n  qn as randomHardColor,\n  Yt as randomPreferColor,\n  Kn as randomSoftColor,\n  Hn as randomString,\n  Ln as range,\n  Er as rangeDate,\n  Ar as rangeMonth,\n  po as removeArrayItem,\n  st as rgbToHex,\n  Bt as rgbToHsl,\n  Ut as rgbToHsv,\n  ct as rgbaToHex,\n  nr as round,\n  so as runParallel,\n  No as runQueueFrame,\n  tr as segmentNumber,\n  Vn as setGlobalCount,\n  Eo as sortByProps,\n  Et as startOfDay,\n  wt as startOfHour,\n  St as startOfMinute,\n  Or as startOfMonth,\n  $r as startOfQuarter,\n  Mt as startOfSecond,\n  At as startOfWeek,\n  Tr as startOfYear,\n  co as supportFlexGap,\n  ao as supportImgLoading,\n  eo as throttle,\n  P as times,\n  Xr as toAttrValue,\n  Oo as toCamelCase,\n  bn as toCapitalCase,\n  Qr as toCssSize,\n  h as toDate,\n  In as toFalse,\n  zt as toFixed,\n  Qn as toGrayScale,\n  Fo as toKebabCase,\n  Me as toNumber,\n  jt as toPrecision,\n  ce as toTrue,\n  go as transformListToMap,\n  bo as transformTree,\n  Mo as walkTree,\n  vr as warnOnce,\n  Bn as writeClipboard\n};\n//# sourceMappingURL=index.mjs.map\n","import { computed, getCurrentScope, onScopeDispose, unref, watch } from 'vue'\n\nimport { noop } from '@vexip-ui/utils'\n\nimport type { MaybeRef } from 'vue'\n\nexport interface UseListenerOptions extends AddEventListenerOptions {\n  /**\n   * 是否禁用整个 hook 的事件处理\n   */\n  disabled?: MaybeRef<boolean>\n}\n\nexport function useListener<E = Event>(\n  target: MaybeRef<EventTarget | null | undefined>,\n  event: string,\n  listener: (event: E) => any,\n  options?: UseListenerOptions | boolean,\n) {\n  if (!target) {\n    return noop\n  }\n\n  const normalizedOptions = computed(() => {\n    if (typeof options === 'boolean') {\n      return { capture: options }\n    }\n\n    return options || {}\n  })\n\n  let remove = noop\n\n  const stopWatch = watch(\n    () => unref(target),\n    el => {\n      remove()\n\n      if (!el) {\n        return\n      }\n\n      const { disabled, ...opts } = normalizedOptions.value\n      const handler = (event: Event) => {\n        if (!unref(disabled)) {\n          listener(event as E)\n        }\n      }\n\n      el.addEventListener(event, handler, opts)\n\n      remove = () => {\n        el.removeEventListener(event, handler, opts)\n        remove = noop\n      }\n    },\n    { immediate: true, flush: 'post' },\n  )\n\n  const stop = () => {\n    stopWatch()\n    remove()\n  }\n\n  getCurrentScope() && onScopeDispose(stop)\n\n  return stop\n}\n","import { getCurrentScope, onScopeDispose, ref, unref, watch } from 'vue'\n\nimport { CLICK_TYPE, dispatchEvent, isClient, noop } from '@vexip-ui/utils'\nimport { useListener } from './listener'\n\nimport type { Ref } from 'vue'\nimport type { TransferNode } from '@vexip-ui/utils'\n\nexport const CLICK_OUTSIDE = 'clickoutside'\n\nconst elements = new Set<TransferNode>()\n\nif (isClient) {\n  document.addEventListener(\n    CLICK_TYPE,\n    (event: Event) => {\n      const target = event.target as Node | null\n      const path = event.composedPath && event.composedPath()\n\n      elements.forEach(el => {\n        if (\n          el !== target &&\n          (path ? !path.includes(el) : !el.contains(target)) &&\n          (!el.__transferElement ||\n            (el.__transferElement !== target && !el.__transferElement.contains(target)))\n        ) {\n          dispatchEvent(el, { type: CLICK_OUTSIDE })\n        }\n      })\n    },\n    true,\n  )\n}\n\n/**\n * 创建一个可以添加 clickoutside 事件的元素 Ref\n *\n * @param handler 事件的回调方法\n * @param target 需要处理的元素 ref，可不传\n */\nexport function useClickOutside(\n  handler: () => void,\n  target: Ref<HTMLElement | null | undefined> = ref(null),\n) {\n  let remove = noop\n\n  const stopWatch = watch(\n    () => unref(target),\n    el => {\n      remove()\n\n      if (!el) {\n        return\n      }\n\n      elements.add(el)\n\n      remove = () => {\n        elements.delete(el)\n        remove = noop\n      }\n    },\n    { immediate: true, flush: 'post' },\n  )\n\n  const stop = () => {\n    stopWatch()\n    remove()\n  }\n\n  getCurrentScope() && onScopeDispose(stop)\n  useListener(target, CLICK_OUTSIDE, handler)\n\n  return target\n}\n","import { nextTick, onBeforeUnmount, onMounted, ref } from 'vue'\n\nimport { noop } from '@vexip-ui/utils'\n\nimport type { Ref } from 'vue'\n\n/**\n * 创建一个观察了最近的上级元素 display 变化的元素 Ref\n *\n * @param displayInit 元素初次显示后执行的回调\n * @returns 观察了 display 变化的元素 Ref\n */\nexport function useDisplay(\n  displayInit = noop,\n  element: Ref<HTMLElement | null | undefined> = ref(null),\n) {\n  let observer: MutationObserver | null\n\n  onMounted(() => {\n    nextTick(() => {\n      const hiddenParentNode = queryOutsideHiddenElement(element.value)\n\n      if (hiddenParentNode) {\n        observer = new MutationObserver(() => {\n          if (hiddenParentNode.style.display !== 'none') {\n            if (typeof displayInit === 'function') {\n              displayInit()\n            }\n\n            observer?.disconnect()\n            observer = null\n          }\n        })\n\n        observer.observe(hiddenParentNode, {\n          attributes: true,\n          childList: true,\n          characterData: true,\n          attributeFilter: ['style'],\n        })\n      } else {\n        typeof displayInit === 'function' && displayInit()\n      }\n    })\n  })\n\n  onBeforeUnmount(() => {\n    observer?.disconnect()\n    observer = null\n  })\n\n  return element\n}\n\nexport function queryOutsideHiddenElement(el?: Element | null) {\n  if (el) {\n    let parentElement = el.parentElement\n\n    while (parentElement && parentElement !== document.body) {\n      if (parentElement.style.display === 'none') {\n        return parentElement\n      }\n\n      parentElement = parentElement.parentElement\n    }\n  }\n\n  return null\n}\n\nexport function isHiddenElement(el?: HTMLElement | null) {\n  if (el?.style.display !== 'none') {\n    return !!queryOutsideHiddenElement(el)\n  }\n\n  return true\n}\n","import {\n  Comment,\n  Fragment,\n  createTextVNode,\n  isVNode,\n  readonly,\n  ref,\n  renderSlot,\n  toRef,\n  unref,\n  watch,\n} from 'vue'\n\nimport { ensureArray, isClient, noop } from '@vexip-ui/utils'\n\nimport type {\n  ComponentPublicInstance,\n  MaybeRef,\n  Ref,\n  Slots,\n  VNode,\n  VNodeChild,\n  VNodeNormalizedChildren,\n} from 'vue'\nimport type { MaybeElement, MaybeInstance } from './types'\n\nexport function createSlotRender(\n  slots: Slots,\n  names: string[]\n): ((params?: any) => VNodeChild) | null\nexport function createSlotRender(\n  slots: Slots,\n  names: string[],\n  fallback: (params?: any) => VNodeChild\n): (params?: any) => VNodeChild\nexport function createSlotRender(\n  slots: Slots,\n  names: string[],\n  fallback?: (params?: any) => VNodeChild,\n) {\n  for (const name of names) {\n    if (slots[name]) {\n      return (params: any) =>\n        renderSlot(slots, name, params, () => {\n          const vnodes = fallback?.(params)\n\n          return vnodes ? ensureArray(vnodes) : []\n        })\n    }\n  }\n\n  return fallback || null\n}\n\nexport function flatVNodes(children: VNodeNormalizedChildren) {\n  const result: VNode[] = []\n  const loop = Array.isArray(children) ? [...children] : []\n\n  while (loop.length) {\n    const vnode = loop.shift()!\n\n    if (vnode === null) continue\n\n    if (Array.isArray(vnode)) {\n      loop.unshift(...vnode)\n    }\n\n    if (\n      typeof vnode !== 'string' &&\n      typeof vnode !== 'number' &&\n      (!isVNode(vnode) || vnode.type === Comment)\n    ) {\n      continue\n    }\n\n    if (typeof vnode === 'string' || typeof vnode === 'number') {\n      result.push(createTextVNode(String(vnode)))\n    } else if (vnode.type === Fragment && Array.isArray(vnode.children)) {\n      loop.unshift(vnode.children)\n    } else {\n      result.push(vnode)\n    }\n  }\n\n  return result\n}\n\nexport function unrefElement<T extends string | MaybeInstance = string | MaybeInstance>(\n  ref: MaybeRef<T>,\n): T extends string | ComponentPublicInstance ? MaybeElement : T {\n  const plain = unref(ref)\n\n  if (typeof plain === 'string') {\n    return (isClient ? document.querySelector(plain) : null) as any\n  }\n\n  return (plain as ComponentPublicInstance)?.$el ?? plain\n}\n\nexport function proxyExposed<T>(vnode: VNode): T {\n  return new Proxy({} as any, {\n    get(_, key) {\n      if (!vnode.component) return undefined\n\n      return (\n        (vnode.component.proxy as any)?.[key] ??\n        (vnode.component.exposeProxy as any)?.[key] ??\n        (vnode.component.exposed as any)?.[key]\n      )\n    },\n  }) as T\n}\n\nexport function watchPauseable(...args: Parameters<typeof watch>) {\n  const active = ref(true)\n  const handle = args[1] || noop\n\n  function pause() {\n    active.value = false\n  }\n\n  function resume() {\n    active.value = true\n  }\n\n  const stop = watch(\n    args[0],\n    (...callbackArgs) =>\n      new Promise<void>((resolve, reject) => {\n        if (active.value) {\n          Promise.resolve(handle(...callbackArgs))\n            .then(resolve)\n            .catch(reject)\n        }\n      }),\n    args[2],\n  )\n\n  return { active: readonly(active), pause, resume, stop }\n}\n\nexport function pickToRefs<T extends Record<any, any>, K extends keyof T>(reactive: T, keys: K[]) {\n  return keys.map(key => toRef(reactive, key)) as { [P in K]: Ref<T[P]> }\n}\n","import { computed, getCurrentScope, isRef, onScopeDispose, ref, watch } from 'vue'\n\nimport { isClient, noop } from '@vexip-ui/utils'\nimport { unrefElement } from './shared/utils'\n\nimport type { ComputedRef, MaybeRef, Ref } from 'vue'\nimport type { MaybeInstance } from './shared/types'\n\nexport interface UseFullScreenResult {\n  target: Ref<MaybeInstance>,\n  supported: boolean,\n  full: ComputedRef<boolean>,\n  enter: (force?: boolean) => Promise<boolean>,\n  exit: (force?: boolean) => Promise<boolean>,\n  toggle: (force?: boolean) => Promise<boolean>\n}\n\ntype PropertiesMap = [\n  'requestFullscreen',\n  'exitFullscreen',\n  'fullscreenElement',\n  'fullscreenEnabled',\n  'fullscreenchange',\n  'fullscreenerror',\n]\n\nconst functionsMap = [\n  [\n    'requestFullscreen',\n    'exitFullscreen',\n    'fullscreenElement',\n    'fullscreenEnabled',\n    'fullscreenchange',\n    'fullscreenerror',\n  ],\n  // New WebKit\n  [\n    'webkitRequestFullscreen',\n    'webkitExitFullscreen',\n    'webkitFullscreenElement',\n    'webkitFullscreenEnabled',\n    'webkitfullscreenchange',\n    'webkitfullscreenerror',\n  ],\n  // Old WebKit\n  [\n    'webkitRequestFullScreen',\n    'webkitCancelFullScreen',\n    'webkitCurrentFullScreenElement',\n    'webkitCancelFullScreen',\n    'webkitfullscreenchange',\n    'webkitfullscreenerror',\n  ],\n  [\n    'mozRequestFullScreen',\n    'mozCancelFullScreen',\n    'mozFullScreenElement',\n    'mozFullScreenEnabled',\n    'mozfullscreenchange',\n    'mozfullscreenerror',\n  ],\n  [\n    'msRequestFullscreen',\n    'msExitFullscreen',\n    'msFullscreenElement',\n    'msFullscreenEnabled',\n    'MSFullscreenChange',\n    'MSFullscreenError',\n  ],\n] as PropertiesMap[]\n\nlet map!: PropertiesMap\n\nif (isClient) {\n  for (const m of functionsMap) {\n    if (m[1] in document) {\n      map = m\n      break\n    }\n  }\n}\n\nconst supported = !!map\nconst notSupportedResult = {\n  supported,\n  full: computed(() => false),\n  enter: noop,\n  exit: noop,\n  toggle: noop,\n}\n\nconst states = new Set<Ref<boolean>>()\nconst subscriptions = new WeakMap<Element, Ref<boolean>>()\n\nif (isClient && map) {\n  const ELEMENT = map[2]\n  const EVENT = map[4]\n\n  document.addEventListener(\n    EVENT,\n    () => {\n      states.forEach(state => {\n        state.value = false\n      })\n\n      if (document[ELEMENT]) {\n        const full = subscriptions.get(document[ELEMENT])\n\n        if (full) {\n          full.value = true\n        }\n      }\n    },\n    false,\n  )\n}\n\nexport function useFullScreen(target: MaybeRef<MaybeInstance> = ref(null)): UseFullScreenResult {\n  const targetRef = computed({\n    get: () => unrefElement(target),\n    set: el => {\n      if (isRef(target)) {\n        target.value = el\n      }\n    },\n  })\n\n  if (!isClient || !supported) {\n    return { ...notSupportedResult, target: targetRef }\n  }\n\n  const [REQUEST, EXIT, ELEMENT] = map\n  const full = ref(false)\n\n  watch(\n    () => unrefElement(target),\n    (el, old) => {\n      old && subscriptions.delete(old)\n      el && subscriptions.set(el, full)\n    },\n    { immediate: true, flush: 'post' },\n  )\n\n  states.add(full)\n\n  if (getCurrentScope()) {\n    onScopeDispose(exit)\n  }\n\n  async function enter(force = false) {\n    await exit()\n\n    const el = unrefElement(target)\n\n    if (el) {\n      if (force || !document[ELEMENT]) {\n        await el[REQUEST]()\n        full.value = true\n\n        return document[ELEMENT] === el\n      }\n    }\n\n    return false\n  }\n\n  async function exit(force = false) {\n    const el = unrefElement(target)\n\n    if (force || (document[ELEMENT] && document[ELEMENT] === el)) {\n      await document[EXIT]()\n      full.value = false\n\n      return document[ELEMENT] !== el\n    }\n\n    return false\n  }\n\n  async function toggle(force = false) {\n    return full.value ? await exit(force) : await enter(force)\n  }\n\n  return {\n    supported,\n    target: targetRef,\n    full: computed(() => full.value),\n    enter,\n    exit,\n    toggle,\n  }\n}\n","import { ref } from 'vue'\n\nimport { useListener } from './listener'\n\nimport type { Ref } from 'vue'\n\nexport function useHover(wrapper: Ref<HTMLElement | null | undefined> = ref(null)) {\n  const isHover = ref(false)\n\n  useListener(wrapper, 'mouseenter', enterWrapper)\n  useListener(wrapper, 'mouseleave', leaveWrapper)\n\n  function enterWrapper() {\n    isHover.value = true\n  }\n\n  function leaveWrapper() {\n    isHover.value = false\n  }\n\n  return { wrapper, isHover }\n}\n","import { getCurrentScope, onScopeDispose, ref, unref, watch } from 'vue'\n\nimport { ensureArray, isClient, noop, toNumber } from '@vexip-ui/utils'\n\nimport type { Ref } from 'vue'\n\nexport type IntersectionHandler = (entry: IntersectionObserverEntry) => any\nexport type UseIntersectionOptions = IntersectionObserverInit & {\n  /**\n   * 元素交叉状态变化时的回调方法\n   */\n  handler: IntersectionHandler,\n  /**\n   * 作用的目标元素的 Ref\n   */\n  target?: Ref<HTMLElement | null | undefined>\n}\n\nconst observerCache = new WeakMap<\n  Element | Document,\n  Map<\n    string,\n    Map<\n      string,\n      { ob: IntersectionObserver, count: number, handlers: WeakMap<Element, IntersectionHandler> }\n    >\n  >\n>()\n\nconst spaceRE = /\\s+/g\nconst unitRE = /(px|%)$/\n\nexport function useIntersection(options: UseIntersectionOptions) {\n  const target = options.target || ref(null)\n\n  if (!isClient) {\n    return { target, disconnect: noop }\n  }\n\n  const { handler } = options\n\n  let root = options.root ?? document\n\n  const threshold = ensureArray(options.threshold || 0).join() || '0'\n  const margin = normalizeMargin(options.rootMargin)\n\n  if (!observerCache.has(root)) {\n    observerCache.set(root, new Map())\n  }\n\n  const thresholdCache = observerCache.get(root)!\n\n  if (!thresholdCache.has(threshold)) {\n    thresholdCache.set(threshold, new Map())\n  }\n\n  const marginCache = thresholdCache.get(threshold)!\n\n  if (!marginCache.has(margin)) {\n    marginCache.set(margin, {\n      ob: new IntersectionObserver(handleIntersect, { ...options, rootMargin: margin }),\n      count: 0,\n      handlers: new WeakMap<Element, IntersectionHandler>(),\n    })\n  }\n\n  let state = marginCache.get(margin)\n  let { ob: observer, handlers } = state!\n\n  let remove = noop\n\n  const stopWatch = watch(\n    () => unref(target),\n    el => {\n      remove()\n\n      if (!el || !observer) {\n        return\n      }\n\n      handlers.set(el, handler)\n      observer.observe(el)\n      state && state.count++\n\n      remove = () => {\n        observer.unobserve(el)\n        handlers.delete(el)\n        state && state.count--\n        remove = noop\n      }\n    },\n    { immediate: true, flush: 'post' },\n  )\n\n  getCurrentScope() && onScopeDispose(disconnect)\n\n  function normalizeMargin(margin?: string) {\n    if (!margin || !margin.trim()) return '_'\n\n    const parts = margin.trim().split(spaceRE, 4)\n    parts.length = 4\n\n    for (let i = 0; i < 4; ++i) {\n      const part = parts[i]\n\n      parts[i] = unitRE.test(part) ? part : `${toNumber(part)}px`\n    }\n\n    return parts.join(' ')\n  }\n\n  function handleIntersect(entries: IntersectionObserverEntry[]) {\n    for (let i = 0, len = entries.length; i < len; ++i) {\n      const entry = entries[i]\n      const handler = handlers.get(entry.target)\n\n      if (typeof handler === 'function') {\n        handler(entry)\n      }\n    }\n  }\n\n  function disconnect() {\n    stopWatch()\n    remove()\n\n    if (!state) return\n\n    if (state.count <= 0) {\n      marginCache.delete(margin)\n\n      if (!marginCache.size) {\n        thresholdCache.delete(threshold)\n\n        if (!thresholdCache.size) {\n          observerCache.delete(root)\n        }\n      }\n    }\n\n    state = undefined\n    observer = undefined!\n    handlers = undefined!\n    root = undefined!\n  }\n\n  return { target, disconnect }\n}\n","import { customRef } from 'vue'\n\nexport function useManualRef() {\n  const updateSet = new Set<() => void>()\n\n  function manualRef<T>(value: T) {\n    return customRef<T>((track, trigger) => {\n      let origin = value\n\n      const update = () => {\n        if (value !== origin) {\n          origin = value\n          trigger()\n        }\n      }\n\n      return {\n        get: () => (track(), value),\n        set: newValue => {\n          if (newValue === value) return\n\n          value = newValue\n          updateSet.add(update)\n        },\n      }\n    })\n  }\n\n  function triggerUpdate() {\n    for (const trigger of updateSet) {\n      trigger()\n    }\n\n    updateSet.clear()\n  }\n\n  return { updateSet, manualRef, triggerUpdate }\n}\n","import { computed, isRef, reactive, ref, unref } from 'vue'\n\nimport { noop } from '@vexip-ui/utils'\nimport { useListener } from './listener'\n\nimport type { MaybeRef, Ref } from 'vue'\n\nexport type ModifierState = Readonly<\n  Omit<Record<string, boolean>, 'activeKeys'> & {\n    activeKeys: Set<string>,\n    resetAll: () => void\n  }\n>\n\nexport interface UseModifierOptions {\n  /**\n   * 作用的目标元素的 Ref\n   */\n  target?: Ref<HTMLElement | null | undefined>,\n  /**\n   * 是否禁用整个 hook 的事件处理\n   */\n  disabled?: MaybeRef<boolean>,\n  /**\n   * 配置键名的别名，会与默认别名动态合并\n   */\n  aliasMap?: Record<string, string>,\n  /**\n   * 是否在目标元素失去焦点时重置修饰符\n   *\n   * @default true\n   */\n  autoReset?: boolean,\n  /**\n   * 事件的 capture 选项\n   *\n   * @default false\n   */\n  capture?: boolean,\n  /**\n   * 事件的 passive 选项\n   *\n   * @default true\n   */\n  passive?: boolean,\n  /**\n   * 是否严格匹配目标元素\n   */\n  strictTarget?: boolean,\n  /**\n   * 键按下的事件回调函数\n   */\n  onKeyDown?: (event: KeyboardEvent, modifier: ModifierState) => void,\n  /**\n   * 键抬起的时间回调函数\n   */\n  onKeyUp?: (event: KeyboardEvent, modifier: ModifierState) => void\n}\n\nconst defaultAliasMap: Record<string, string> = {\n  ctrl: 'control',\n  command: 'meta',\n  cmd: 'meta',\n  option: 'alt',\n  up: 'arrowup',\n  down: 'arrowdown',\n  left: 'arrowleft',\n  right: 'arrowright',\n}\n\nconst separatorRE = /[+_-]/\nconst splitRE = /[+_-]/g\n\nconst internalProps = ['activeKeys', 'resetAll']\n\nexport function useModifier(options: UseModifierOptions = {}) {\n  const {\n    autoReset = true,\n    capture = false,\n    passive = true,\n    strictTarget = false,\n    onKeyDown = noop,\n    onKeyUp = noop,\n  } = options\n\n  const target = options.target || ref(null)\n  const disabled = isRef(options.disabled) ? options.disabled : ref(options.disabled || false)\n  const aliasMap = { ...defaultAliasMap, ...(options.aliasMap || {}) }\n  const activeKeys = reactive(new Set<string>())\n  const metaDeps = new Set<string>()\n  const modifier: Record<string, any> = reactive({ activeKeys, resetAll })\n\n  function setModifier(key: string, value: boolean) {\n    if (key in modifier) {\n      modifier[key] = value\n    }\n  }\n\n  function updateModifier(event: KeyboardEvent, value: boolean) {\n    const key = event.key?.toLocaleLowerCase()\n    const code = event.code?.toLocaleLowerCase()\n    const keys = [code, key].filter(Boolean)\n\n    for (const key of keys) {\n      activeKeys[value ? 'add' : 'delete'](key)\n      setModifier(key, value)\n    }\n\n    if (!value && key === 'meta') {\n      for (const key of metaDeps) {\n        activeKeys.delete(key)\n        setModifier(key, false)\n      }\n\n      metaDeps.clear()\n    } else if (\n      value &&\n      typeof event.getModifierState === 'function' &&\n      event.getModifierState('Meta')\n    ) {\n      for (const key of [...activeKeys, ...keys]) {\n        metaDeps.add(key)\n      }\n    }\n  }\n\n  function resetAll() {\n    Object.keys(modifier).forEach(key => {\n      modifier[key] = false\n    })\n\n    modifier.activeKeys = activeKeys\n    modifier.resetAll = resetAll\n  }\n\n  const modifierProxy = new Proxy(modifier, {\n    get(target, prop, receiver) {\n      if (typeof prop !== 'string' || internalProps.includes(prop)) {\n        return Reflect.get(target, prop, receiver)\n      }\n\n      prop = prop.toLocaleLowerCase()\n\n      if (prop in aliasMap) {\n        prop = aliasMap[prop]\n      }\n\n      if (!(prop in modifier)) {\n        if (separatorRE.test(prop)) {\n          const keys = prop.split(splitRE).map(key => key.trim())\n\n          modifier[prop] = computed(() => keys.every(key => unref(modifierProxy[key])))\n        } else {\n          modifier[prop] = ref(activeKeys.has(prop))\n        }\n      }\n\n      return unref(Reflect.get(target, prop, receiver))\n    },\n  })\n\n  useListener(\n    target,\n    'keydown',\n    (event: KeyboardEvent) => {\n      if (strictTarget && event.target !== unref(target)) {\n        return\n      }\n\n      updateModifier(event, true)\n      onKeyDown(event, modifierProxy)\n    },\n    { capture, passive, disabled },\n  )\n  useListener(\n    target,\n    'keyup',\n    (event: KeyboardEvent) => {\n      if (strictTarget && event.target !== unref(target)) {\n        return\n      }\n\n      updateModifier(event, false)\n      onKeyUp(event, modifierProxy)\n    },\n    { capture, passive, disabled },\n  )\n\n  if (autoReset) {\n    useListener(target, 'blur', resetAll, { capture, passive, disabled })\n  }\n\n  return { target, modifier: modifierProxy as ModifierState }\n}\n","import { nextTick, onBeforeUnmount, onMounted, readonly, ref } from 'vue'\n\nexport function useMounted(wait?: 'tick' | 'frame') {\n  const isMounted = ref(false)\n\n  const mount = () => (isMounted.value = true)\n\n  onMounted(() => {\n    if (wait === 'tick') {\n      nextTick(mount)\n    } else if (wait === 'frame') {\n      requestAnimationFrame(mount)\n    } else {\n      mount()\n    }\n  })\n\n  onBeforeUnmount(() => {\n    isMounted.value = false\n  })\n\n  return { isMounted: readonly(isMounted) }\n}\n","import { computed, isRef, ref } from 'vue'\n\nimport { throttle } from '@vexip-ui/utils'\nimport { useListener } from './listener'\n\nimport type { MaybeRef, Ref } from 'vue'\n\nexport interface MovingState {\n  xStart: number,\n  yStart: number,\n  xEnd: number,\n  yEnd: number,\n  clientX: number,\n  clientY: number,\n  deltaX: number,\n  deltaY: number,\n  lazy: boolean,\n  [custom: string]: unknown\n}\n\nexport interface UseMovingOptions {\n  /**\n   * 作用的目标元素的 Ref\n   */\n  target?: Ref<HTMLElement | null | undefined>,\n  /**\n   * 横向位置的初始值\n   */\n  x?: MaybeRef<number>,\n  /**\n   * 纵向位置的初始值\n   */\n  y?: MaybeRef<number>,\n  /**\n   * 为否为懒加载，开启后会在 End 事件再更新位置状态\n   */\n  lazy?: MaybeRef<boolean>,\n  /**\n   * 是否禁用整个 hook 的事件处理\n   */\n  disabled?: MaybeRef<boolean>,\n  /**\n   * 事件的 capture 选项\n   *\n   * @default true\n   */\n  capture?: boolean,\n  /**\n   * 是否阻止 MouseDown 事件冒泡和默认行为\n   *\n   * @default true\n   */\n  stopMouse?: boolean,\n  /**\n   * 是否阻止 TouchStart 事件冒泡和默认行为\n   *\n   * @default true\n   */\n  stopTouch?: boolean,\n  /**\n   * 移动开始时的回调函数，返回 false 可以阻止本次移动\n   */\n  onStart?: (state: MovingState, event: PointerEvent) => any,\n  /**\n   * 移动中的回调函数\n   */\n  onMove?: (state: MovingState, event: PointerEvent) => void,\n  /**\n   * 移动结束时的回调函数\n   */\n  onEnd?: (state: MovingState, event: PointerEvent) => void\n}\n\nfunction disableEvent<E extends Event>(event: E) {\n  if (event.cancelable) {\n    event.stopPropagation()\n    event.preventDefault()\n  }\n}\n\nexport function useMoving(options: UseMovingOptions) {\n  const target = options.target || ref(null)\n  const x = isRef(options.x) ? options.x : ref(0)\n  const y = isRef(options.y) ? options.y : ref(0)\n  const lazy = isRef(options.lazy) ? options.lazy : ref(options.lazy || false)\n  const disabled = isRef(options.disabled) ? options.disabled : ref(options.disabled || false)\n\n  const { capture = true, stopMouse = true, stopTouch = true } = options\n\n  const moving = ref(false)\n  const internalState: MovingState = {\n    xStart: 0,\n    yStart: 0,\n    xEnd: 0,\n    yEnd: 0,\n    clientX: 0,\n    clientY: 0,\n    deltaX: 0,\n    deltaY: 0,\n    lazy: false,\n  }\n\n  let current = 0\n  let record = 0\n\n  const throttleMove = throttle((event: PointerEvent) => {\n    if (record < current) return\n\n    updateState(event)\n\n    if (!internalState.lazy) {\n      x.value = internalState.xEnd\n      y.value = internalState.yEnd\n    }\n\n    options.onMove?.(internalState, event)\n  })\n\n  function start(event: PointerEvent) {\n    if (disabled.value) return\n\n    Object.assign(internalState, {\n      xStart: x.value,\n      yStart: y.value,\n      xEnd: x.value,\n      yEnd: y.value,\n      clientX: event.clientX,\n      clientY: event.clientY,\n      lazy: lazy.value,\n    })\n\n    if (options.onStart?.(internalState, event) === false) {\n      return\n    }\n\n    document.addEventListener('pointermove', move, { capture })\n    document.addEventListener('pointerup', end, { capture })\n\n    record = current\n    moving.value = true\n  }\n\n  function move(event: PointerEvent) {\n    if (disabled.value) return\n\n    disableEvent(event)\n    throttleMove(event)\n  }\n\n  function end(event: PointerEvent) {\n    document.removeEventListener('pointermove', move, { capture })\n    document.removeEventListener('pointerup', end, { capture })\n\n    if (disabled.value) return\n\n    updateState(event)\n\n    if (internalState.lazy) {\n      x.value = internalState.xEnd\n      y.value = internalState.yEnd\n    }\n\n    moving.value = false\n    ++current\n\n    options.onEnd?.(internalState, event)\n  }\n\n  function updateState(event: PointerEvent) {\n    const { clientX, clientY } = event\n    const { xStart, yStart, clientX: clientXStart, clientY: clientYStart } = internalState\n    const deltaX = clientX - clientXStart\n    const deltaY = clientY - clientYStart\n\n    internalState.deltaX = deltaX\n    internalState.deltaY = deltaY\n    internalState.xEnd = xStart + deltaX\n    internalState.yEnd = yStart + deltaY\n  }\n\n  useListener(target, 'pointerdown', start, { capture })\n\n  stopMouse && useListener(target, 'mousedown', disableEvent, { capture })\n  stopTouch && useListener(target, 'touchstart', disableEvent, { capture })\n\n  return {\n    target,\n    moving: computed(() => moving.value),\n    x,\n    y,\n    lazy,\n    disabled,\n  }\n}\n","import { onBeforeUnmount, ref } from 'vue'\n\nimport { throttle } from '@vexip-ui/utils'\n\nimport type { Ref } from 'vue'\n\nexport interface UsePointerOption {\n  /**\n   * 横向位置的初始值\n   */\n  x?: number,\n  /**\n   * 纵向位置的初始值\n   */\n  y?: number,\n  /**\n   * 是否手动停止，默认情况下会在组件的 BeforeUnmount 生命周期注销\n   *\n   * @default false\n   */\n  manualStop?: boolean\n}\n\ninterface PointerState {\n  x: Ref<number>,\n  y: Ref<number>\n}\n\nconst registered = new Set<PointerState>()\nconst record = new Map<'x' | 'y', number>()\n\nrecord.set('x', 0)\nrecord.set('y', 0)\n\nfunction handler(event: PointerEvent) {\n  const { pageX, pageY } = event\n\n  record.set('x', pageX)\n  record.set('y', pageY)\n\n  registered.forEach(state => {\n    state.x.value = pageX\n    state.y.value = pageY\n  })\n}\n\nconst throttleHandler = throttle(handler)\n\nfunction register(state: PointerState) {\n  if (!registered.size && window) {\n    record.set('x', 0)\n    record.set('y', 0)\n    window.addEventListener('pointermove', throttleHandler, { passive: true })\n  }\n\n  registered.add(state)\n}\n\nfunction unregister(state: PointerState) {\n  registered.delete(state)\n\n  if (!registered.size && window) {\n    window.removeEventListener('pointermove', throttleHandler)\n  }\n}\n\nexport function usePointer(options: UsePointerOption = {}) {\n  const x = ref(options.x ?? record.get('x')!)\n  const y = ref(options.y ?? record.get('y')!)\n\n  const state = { x, y }\n\n  register(state)\n\n  if (!options.manualStop) {\n    onBeforeUnmount(() => {\n      unregister(state)\n    })\n  }\n\n  return { ...state, unregister: () => unregister(state) }\n}\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          var _overflowsData$;\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;\n          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return ['transform', 'translate', 'scale', 'rotate', 'perspective'].some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","var resizeObservers = [];\nexport { resizeObservers };\n","import { resizeObservers } from '../utils/resizeObservers';\nvar hasActiveObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\nexport { hasActiveObservations };\n","import { resizeObservers } from '../utils/resizeObservers';\nvar hasSkippedObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\nexport { hasSkippedObservations };\n","var msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\nexport { deliverResizeLoopError };\n","var ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n    ResizeObserverBoxOptions[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\nexport { ResizeObserverBoxOptions };\n","export var freeze = function (obj) { return Object.freeze(obj); };\n","import { freeze } from './utils/freeze';\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        freeze(this);\n    }\n    return ResizeObserverSize;\n}());\nexport { ResizeObserverSize };\n","import { freeze } from './utils/freeze';\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return freeze(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\nexport { DOMRectReadOnly };\n","var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\nexport { isSVG, isHidden, isElement, isReplacedElement };\n","export var global = typeof window !== 'undefined' ? window : {};\n","import { ResizeObserverBoxOptions } from '../ResizeObserverBoxOptions';\nimport { ResizeObserverSize } from '../ResizeObserverSize';\nimport { DOMRectReadOnly } from '../DOMRectReadOnly';\nimport { isSVG, isHidden } from '../utils/element';\nimport { freeze } from '../utils/freeze';\nimport { global } from '../utils/global';\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(global.navigator && global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || '0'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = freeze({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if (isHidden(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === 'border-box';\n    var switchSizes = verticalRegexp.test(cs.writingMode || '');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = freeze({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\nexport { calculateBoxSize, calculateBoxSizes };\n","import { calculateBoxSizes } from './algorithms/calculateBoxSize';\nimport { freeze } from './utils/freeze';\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = calculateBoxSizes(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = freeze([boxes.borderBoxSize]);\n        this.contentBoxSize = freeze([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\nexport { ResizeObserverEntry };\n","import { isHidden } from '../utils/element';\nvar calculateDepthForNode = function (node) {\n    if (isHidden(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\nexport { calculateDepthForNode };\n","import { resizeObservers } from '../utils/resizeObservers';\nimport { ResizeObserverEntry } from '../ResizeObserverEntry';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nimport { calculateBoxSize } from './calculateBoxSize';\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new ResizeObserverEntry(ot.target);\n            var targetDepth = calculateDepthForNode(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\nexport { broadcastActiveObservations };\n","import { resizeObservers } from '../utils/resizeObservers';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nvar gatherActiveObservationsAtDepth = function (depth) {\n    resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if (calculateDepthForNode(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\nexport { gatherActiveObservationsAtDepth };\n","import { hasActiveObservations } from '../algorithms/hasActiveObservations';\nimport { hasSkippedObservations } from '../algorithms/hasSkippedObservations';\nimport { deliverResizeLoopError } from '../algorithms/deliverResizeLoopError';\nimport { broadcastActiveObservations } from '../algorithms/broadcastActiveObservations';\nimport { gatherActiveObservationsAtDepth } from '../algorithms/gatherActiveObservationsAtDepth';\nvar process = function () {\n    var depth = 0;\n    gatherActiveObservationsAtDepth(depth);\n    while (hasActiveObservations()) {\n        depth = broadcastActiveObservations();\n        gatherActiveObservationsAtDepth(depth);\n    }\n    if (hasSkippedObservations()) {\n        deliverResizeLoopError();\n    }\n    return depth > 0;\n};\nexport { process };\n","var trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode('');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = \"\".concat(toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\nexport { queueMicroTask };\n","import { queueMicroTask } from './queueMicroTask';\nvar queueResizeObserver = function (cb) {\n    queueMicroTask(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\nexport { queueResizeObserver };\n","import { process } from './process';\nimport { global } from './global';\nimport { queueResizeObserver } from './queueResizeObserver';\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        queueResizeObserver(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = process();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\nexport { scheduler, updateCount };\n","import { ResizeObserverBoxOptions } from './ResizeObserverBoxOptions';\nimport { calculateBoxSize } from './algorithms/calculateBoxSize';\nimport { isSVG, isReplacedElement } from './utils/element';\nvar skipNotifyOnElement = function (target) {\n    return !isSVG(target)\n        && !isReplacedElement(target)\n        && getComputedStyle(target).display === 'inline';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = calculateBoxSize(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\nexport { ResizeObservation };\n","var ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\nexport { ResizeObserverDetail };\n","import { scheduler, updateCount } from './utils/scheduler';\nimport { ResizeObservation } from './ResizeObservation';\nimport { ResizeObserverDetail } from './ResizeObserverDetail';\nimport { resizeObservers } from './utils/resizeObservers';\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && resizeObservers.push(detail);\n            detail.observationTargets.push(new ResizeObservation(target, options && options.box));\n            updateCount(1);\n            scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            updateCount(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\nexport { ResizeObserverController };\n","import { ResizeObserverController } from './ResizeObserverController';\nimport { isElement } from './utils/element';\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\nexport { ResizeObserver };\n","import { type MaybeRef, getCurrentScope, onScopeDispose, unref, watch } from 'vue'\n\nimport { isClient, noop } from '@vexip-ui/utils'\nimport { ResizeObserver } from '@juggle/resize-observer'\n\nexport interface ResizeInfo extends ResizeObserverEntry {\n  offsetWidth: number,\n  offsetHeight: number,\n  width: number,\n  height: number\n}\n\nexport type ResizeHandler = (entry: ResizeInfo) => any\n\nexport interface UseResizeOptions {\n  /**\n   * 作用的目标元素的 Ref\n   */\n  target?: MaybeRef<HTMLElement | null | undefined>,\n  onResize?: ResizeHandler\n}\n\nconst handlerMap = new WeakMap<Element, ResizeHandler>()\n\nfunction handleResize(entries: ResizeObserverEntry[]) {\n  for (let i = 0, len = entries.length; i < len; ++i) {\n    const entry = entries[i]\n    const handler = handlerMap.get(entry.target)\n\n    if (typeof handler === 'function') {\n      const { inlineSize, blockSize } = entry.borderBoxSize?.[0] ?? {}\n      const { offsetWidth, offsetHeight } = entry.target as HTMLElement\n\n      handler(\n        Object.assign(entry, {\n          offsetWidth,\n          offsetHeight,\n          width: inlineSize ?? offsetWidth,\n          height: blockSize ?? offsetHeight,\n        }),\n      )\n    }\n  }\n}\n\nconst resizeObserver = new (isClient ? window.ResizeObserver || ResizeObserver : ResizeObserver)(\n  handleResize,\n)\n\nexport function observeResize(el: Element, handler: ResizeHandler) {\n  handlerMap.set(el, handler)\n  resizeObserver.observe(el)\n}\n\nexport function unobserveResize(el: Element) {\n  if (handlerMap.has(el)) {\n    resizeObserver.unobserve(el)\n    handlerMap.delete(el)\n  }\n}\n\nexport function useResize(options: UseResizeOptions = {}) {\n  let remove = noop\n\n  const stopWatch = watch(\n    () => unref(options.target),\n    el => {\n      remove()\n\n      if (!el || typeof options.onResize !== 'function') {\n        return\n      }\n\n      observeResize(el, options.onResize)\n\n      remove = () => {\n        unobserveResize(el)\n        remove = noop\n      }\n    },\n    { immediate: true },\n  )\n\n  const unobserve = () => {\n    stopWatch()\n    remove()\n  }\n\n  getCurrentScope() && onScopeDispose(unobserve)\n\n  return {\n    /**\n     * @deprecated Will be removed in next major version, please directly use `observeResize` from imports.\n     */\n    observeResize,\n    /**\n     * @deprecated Will be removed in next major version, please directly use `unobserveResize` from imports.\n     */\n    unobserveResize,\n    unobserve,\n  }\n}\n","import { computed, ref } from 'vue'\n\nimport { isClient } from '@vexip-ui/utils'\nimport { observeResize } from './resize'\n\nimport type { Ref } from 'vue'\n\nconst rtl = ref(false)\nconst computedRtl: Ref<boolean> = computed(() => rtl.value)\n\nconst elId = '__rtl_observer__'\n\nexport function useRtl() {\n  if (isClient && !document.querySelector(`#${elId}`)) {\n    initObserver()\n  }\n\n  return { isRtl: computedRtl }\n}\n\nfunction initObserver() {\n  if (!isClient) return\n\n  const style = document.createElement('style')\n  const content = `#${elId} { width: 1px } html.rtl #${elId}, html[dir='rtl'] #${elId} { width: 2px }`\n\n  style.textContent = content\n  document.head.appendChild(style)\n\n  const observer = document.createElement('div')\n\n  observer.id = elId\n  observer.role = 'none'\n  observer.style.cssText =\n    'position: fixed; top -10px; left: -10px; height: 1px; visibility: hidden;'\n\n  observeResize(observer, () => {\n    if (!isClient) return\n\n    rtl.value =\n      document.documentElement.classList.contains('rtl') ||\n      document.documentElement.getAttribute('dir') === 'rtl'\n  })\n\n  document.body.appendChild(observer)\n}\n","import { onMounted, ref, shallowRef, unref, watch, watchEffect } from 'vue'\n\nimport {\n  arrow,\n  autoUpdate,\n  computePosition,\n  flip,\n  hide,\n  offset,\n  platform,\n  shift,\n} from '@floating-ui/dom'\nimport { useRtl } from './rtl'\nimport { isClient } from '@vexip-ui/utils'\n\nimport type { MaybeRef, Ref } from 'vue'\nimport type {\n  ComputePositionConfig,\n  Middleware,\n  OffsetOptions,\n  Placement,\n  ShiftOptions,\n  VirtualElement,\n} from '@floating-ui/dom'\nimport type { TransferNode } from '@vexip-ui/utils'\n\nexport interface UsePopperOptions {\n  /**\n   * popper 元素出现的位置\n   */\n  placement: MaybeRef<Placement>,\n  /**\n   * popper 元素需要迁移至的目标选择器，为 true 时会迁移至 body\n   */\n  transfer?: MaybeRef<boolean | string>,\n  /**\n   * 设置是否为从右向左的阅读方向\n   */\n  isRtl?: MaybeRef<boolean>,\n  /**\n   * 包围元素，用于判断 clickoutside 事件\n   *\n   * 即使 popper 元素迁移至 wrapper 元素外部，点击 popper 元素时仍认为处于 wrapper 元素内部\n   */\n  wrapper?: Ref<HTMLElement | null | undefined>,\n  /**\n   * 设置 popper 元素为否需要 drop，此时 transform-origin 会自动调整\n   */\n  isDrop?: MaybeRef<boolean>,\n  /**\n   * 参考元素，popper 元素的位置计算依据\n   */\n  reference?: Ref<HTMLElement | VirtualElement | null | undefined>,\n  /**\n   * popper 元素\n   */\n  popper?: Ref<HTMLElement | null | undefined>,\n  /**\n   * arrow 元素\n   */\n  arrow?: Ref<HTMLElement | null | undefined>,\n  /**\n   * popper 元素的偏移量，可传入一个回调函数\n   */\n  offset?: MaybeRef<number[] | OffsetOptions>,\n  /**\n   * popper 元素是否限制在窗口内\n   */\n  shift?: MaybeRef<boolean | ShiftOptions>,\n  /**\n   * 设置是否自动更新 popper 元素\n   *\n   * @default false\n   */\n  autoUpdate?: boolean\n}\n\nexport type { Placement, VirtualElement }\n\nexport const placementWhileList = Object.freeze<Placement[]>([\n  'top',\n  'top-start',\n  'top-end',\n  'bottom',\n  'bottom-start',\n  'bottom-end',\n  'left',\n  'left-start',\n  'left-end',\n  'right',\n  'right-start',\n  'right-end',\n])\n\nexport function usePopper(initOptions: UsePopperOptions) {\n  const { transfer, wrapper, isDrop = false } = initOptions\n\n  const reference: Ref<HTMLElement | null | undefined> =\n    (initOptions.reference as any) ?? shallowRef(null)\n  const popper: Ref<HTMLElement | null | undefined> = initOptions.popper ?? shallowRef(null)\n  const arrowRef: Ref<HTMLElement | null | undefined> = initOptions.arrow ?? shallowRef(null)\n\n  const placement = ref(unref(initOptions.placement))\n  const transferTo = ref('')\n  const isRtl = initOptions.isRtl ?? useRtl().isRtl\n\n  if (wrapper) {\n    watchEffect(() => {\n      const wrapperEl = unref(wrapper)\n      const popperEl = unref(popper)\n\n      if (wrapperEl) {\n        ;(wrapperEl as TransferNode).__transferElement = popperEl\n      }\n    })\n  }\n\n  if (transfer != null) {\n    watch(\n      () => unref(transfer),\n      value => {\n        setTransferTo(value)\n        updatePopper()\n      },\n    )\n\n    setTransferTo(unref(transfer))\n  }\n\n  onMounted(() => {\n    requestAnimationFrame(() => {\n      watchEffect(updatePopperInternal)\n    })\n  })\n\n  let cleanup: (() => void) | undefined\n\n  async function updatePopperInternal() {\n    if (!isClient) return\n\n    cleanup?.()\n\n    const referenceEl = unref(reference)\n    const popperEl = unref(popper)\n\n    if (!referenceEl || !popperEl) return\n\n    const arrowEl = unref(arrowRef)\n\n    const middleware: Middleware[] = [flip()]\n\n    if (isDrop) {\n      middleware.push({\n        name: 'origin',\n        fn({ placement, elements }) {\n          const origin = setPopperDropOrigin(placement)\n\n          if (origin) {\n            elements.floating.style.transformOrigin = origin\n          }\n\n          return {}\n        },\n      })\n    }\n\n    if (initOptions.offset) {\n      let offsetOptions = unref(initOptions.offset)\n\n      if (Array.isArray(offsetOptions)) {\n        offsetOptions = {\n          mainAxis: offsetOptions[1],\n          crossAxis: offsetOptions[0],\n        }\n      }\n\n      middleware.push(offset(offsetOptions))\n    }\n\n    if (initOptions.shift) {\n      let shiftOptions = unref(initOptions.shift)\n\n      if (typeof shiftOptions === 'boolean') {\n        shiftOptions = {}\n      }\n\n      middleware.push(shift(shiftOptions))\n    }\n\n    if (arrowEl) {\n      middleware.push(arrow({ element: arrowEl }))\n    }\n\n    middleware.push(hide({ strategy: 'escaped' }))\n\n    const rtl = unref(isRtl) || false\n    const options: ComputePositionConfig = {\n      middleware,\n      placement: unref(initOptions.placement),\n      platform: {\n        ...platform,\n        isRTL: async () => rtl,\n      },\n    }\n\n    const update = async () => {\n      const {\n        x,\n        y,\n        placement: activePlacement,\n        strategy,\n        middlewareData,\n      } = await computePosition(referenceEl, popperEl, options)\n\n      if (unref(reference) !== referenceEl) {\n        if (unref(popper) === popperEl) {\n          Object.assign(popperEl.style, {\n            position: '',\n            top: '',\n            left: '',\n          })\n        }\n\n        return\n      }\n\n      const style: Partial<CSSStyleDeclaration> = {\n        position: strategy,\n        top: `${y}px`,\n        left: `${x}px`,\n      }\n\n      // if (middlewareData.hide?.escaped) {\n      //   style.visibility = 'hidden'\n      // } else {\n      //   style.visibility = ''\n      // }\n\n      if (arrowEl) {\n        if (middlewareData.arrow) {\n          const { x, y } = middlewareData.arrow\n\n          Object.assign(arrowEl.style, {\n            top: y != null ? `${y}px` : '',\n            left: x != null ? `${x}px` : '',\n          })\n        } else {\n          Object.assign(arrowEl.style, { top: '', left: '' })\n        }\n      }\n\n      Object.assign(popperEl.style, style)\n      popperEl.dataset.popperPlacement = activePlacement\n      placement.value = activePlacement\n    }\n\n    if (initOptions.autoUpdate) {\n      cleanup = autoUpdate(referenceEl, popperEl, update)\n    }\n\n    await update()\n  }\n\n  const updatePopper = () => {\n    return new Promise<void>(resolve => {\n      requestAnimationFrame(() => {\n        updatePopperInternal().then(resolve)\n      })\n    })\n  }\n\n  function setTransferTo(value: boolean | string) {\n    transferTo.value = typeof value === 'boolean' ? (value ? 'body' : '') : value\n  }\n\n  // function normalizePlacement(placement: Placement, rtl: boolean) {\n  //   if (!rtl) return placement\n\n  //   let [start, end] = placement.split('-')\n\n  //   if (start === 'left' || start === 'right') {\n  //     start = start === 'left' ? 'right' : 'left'\n  //   } else {\n  //     if (!end) return placement\n\n  //     end = end === 'start' ? 'end' : 'start'\n  //   }\n\n  //   return `${start}-${end}` as Placement\n  // }\n\n  function setPopperDropOrigin(placement: Placement) {\n    if (placement !== 'left' && placement !== 'right') {\n      const [start, end] = placement.split('-')\n\n      return start === 'bottom' || (start !== 'top' && end === 'start')\n        ? 'center top'\n        : 'center bottom'\n    }\n  }\n\n  return {\n    wrapper,\n    reference,\n    popper,\n    placement,\n    transferTo,\n    updatePopper,\n  }\n}\n","import { reactive, ref, watch } from 'vue'\n\nimport { isClient } from '@vexip-ui/utils'\nimport { observeResize } from './resize'\n\nimport type { Ref } from 'vue'\nimport type { MaybeElement } from './shared/types'\n\nexport interface InitThemeOptions {\n  name: string,\n  rootClass?: string,\n  varsClass?: string\n}\n\nconst styleId = '__theme_style__'\nconst elClass = '__theme_observer__'\n\nconst elCache = new WeakMap<Element, Element>()\n\nexport function useTheme(wrapper?: MaybeElement) {\n  const theme = ref<string>()\n\n  if (isClient) {\n    wrapper = wrapper || document.body\n\n    let observer = elCache.get(wrapper)\n\n    if (!observer) {\n      observer = createObserver(theme)!\n      wrapper.appendChild(observer)\n      elCache.set(wrapper, observer)\n    }\n  }\n\n  return { theme }\n}\n\nconst activeThemes = reactive(new Map<string, string[]>())\nconst themeWidths = new Map<number, string>()\n\nwatch(activeThemes, () => {\n  if (!isClient) return\n\n  themeWidths.clear()\n\n  const prevStyle = document.head.querySelector(`#${styleId}`)\n\n  if (prevStyle) {\n    document.head.removeChild(prevStyle)\n  }\n\n  const style = document.createElement('style')\n\n  let content = `.${elClass} { width: 1px }`\n  let width = 1\n\n  for (const [name, [rootClass, varsClass]] of activeThemes.entries()) {\n    content += ` html.${rootClass} .${elClass}, .${varsClass} .${elClass} { width: ${++width}px }`\n    themeWidths.set(width, name)\n  }\n\n  style.textContent = content\n  style.id = styleId\n  document.head.appendChild(style)\n})\n\nexport function addActiveThemes(themes: (string | InitThemeOptions)[]) {\n  for (const theme of themes) {\n    const {\n      name,\n      rootClass = name,\n      varsClass = `vxp-theme-vars-${rootClass}`,\n    } = typeof theme === 'string' ? ({ name: theme } as InitThemeOptions) : theme\n\n    activeThemes.set(name, [rootClass, varsClass])\n  }\n}\n\nexport function setActiveThemes(themes: (string | InitThemeOptions)[]) {\n  activeThemes.clear()\n  addActiveThemes(themes)\n}\n\nlet idCount = 0\n\nfunction getElId() {\n  return `__theme_observer_${idCount++}__`\n}\n\nfunction createObserver(theme: Ref<string | undefined>) {\n  if (!isClient) return\n\n  const observer = document.createElement('div')\n\n  observer.id = getElId()\n  observer.className = elClass\n  observer.role = 'none'\n  observer.style.cssText =\n    'position: fixed; top -10px; left: -10px; height: 1px; visibility: hidden;'\n\n  observeResize(observer, entry => {\n    if (!isClient) return\n\n    const width = entry.borderBoxSize?.[0].inlineSize ?? entry.contentRect.width\n\n    theme.value = themeWidths.get(width)\n  })\n\n  return observer\n}\n","import { onScopeDispose } from 'vue'\n\n/**\n * 获取用于记录 `setTimeout` 返回值的对象，记录的定时器会在作用域消除时自动清理\n */\nexport function useSetTimeout() {\n  const timer: Record<string, any> = {}\n\n  onScopeDispose(() => {\n    Object.keys(timer).forEach(key => {\n      clearTimeout(timer[key])\n    })\n  })\n\n  return { timer }\n}\n\n/**\n * 获取用于记录 `setInterval` 返回值的对象，记录的定时器会在作用域消除时自动清理\n */\nexport function useSetInterval() {\n  const timer: Record<string, any> = {}\n\n  onScopeDispose(() => {\n    Object.keys(timer).forEach(key => {\n      clearInterval(timer[key])\n    })\n  })\n\n  return { timer }\n}\n\n/**\n * 获取用于记录 `requestAnimationFrame` 返回值的对象，记录的定时器会在作用域消除时自动清理\n */\nexport function useRaf() {\n  const timer: Record<string, any> = {}\n\n  onScopeDispose(() => {\n    Object.keys(timer).forEach(key => {\n      cancelAnimationFrame(timer[key])\n    })\n  })\n\n  return { timer }\n}\n\n/**\n * 获取三个分别用于记录 `setTimeout`、`setInterval` 和 `requestAnimationFrame` 返回值的对象\n *\n * 记录在这些对象上的定时器将会在作用域消除时自动清理\n */\nexport function useTimerRecord() {\n  const { timer: timeout } = useSetTimeout()\n  const { timer: interval } = useSetInterval()\n  const { timer: raf } = useRaf()\n\n  return { timeout, interval, raf }\n}\n","import type { Ref } from 'vue'\n\nexport function useTriggerHandler(trigger: Ref<string>, currentVisible: Ref<boolean>, delay = 100) {\n  let timer: ReturnType<typeof setTimeout>\n\n  function handleTriggerEnter() {\n    if (trigger.value === 'hover') {\n      clearTimeout(timer)\n\n      timer = setTimeout(() => {\n        currentVisible.value = true\n      }, delay)\n    }\n  }\n\n  function handleTriggerLeave() {\n    if (trigger.value === 'hover') {\n      clearTimeout(timer)\n\n      timer = setTimeout(() => {\n        currentVisible.value = false\n      }, delay)\n    }\n  }\n\n  function handleTriggerClick() {\n    if (trigger.value === 'click') {\n      currentVisible.value = !currentVisible.value\n    }\n  }\n\n  return {\n    handleTriggerEnter,\n    handleTriggerLeave,\n    handleTriggerClick,\n  }\n}\n","import { computed, onScopeDispose, ref, unref, watch } from 'vue'\n\nimport { createBITree, isDefined, nextFrameOnce, noop } from '@vexip-ui/utils'\nimport { isHiddenElement } from './display'\nimport { observeResize, unobserveResize } from './resize'\n\nimport type { MaybeRef } from 'vue'\n\ntype Key = number | string | symbol\ntype Data = Record<string, any>\ntype Behavior = ScrollToOptions['behavior']\n\nexport interface VirtualOptions<T extends Data> {\n  /**\n   * 虚拟滚动的元素\n   */\n  items: MaybeRef<T[]>,\n  /**\n   * 设置元素的最小高度\n   */\n  itemSize: MaybeRef<number>,\n  /**\n   * 设置元素是否为固定高度，固定高度时不处理 resize\n   */\n  itemFixed: MaybeRef<boolean>,\n  /**\n   * 元素的主键\n   */\n  idKey: MaybeRef<keyof T>,\n  /**\n   * 默认停留在的元素的主键，未实现\n   */\n  defaultKeyAt?: Key,\n  /**\n   * 设置前后的缓冲元素的个数\n   */\n  bufferSize?: MaybeRef<number>,\n  /**\n   * 虚拟滚动的包围元素\n   */\n  wrapper?: MaybeRef<HTMLElement | null | undefined>,\n  /**\n   * 是否自动观察 wrapper 缩放\n   *\n   * @default true\n   */\n  autoResize?: boolean\n}\n\nexport function useVirtual<T extends Data = Data>(options: VirtualOptions<T>) {\n  const {\n    items,\n    itemSize,\n    itemFixed,\n    idKey,\n    defaultKeyAt,\n    bufferSize = ref(5),\n    wrapper = ref(null),\n    autoResize = true,\n  } = options\n\n  const indexMap = computed(() => {\n    const itemList = unref(items)\n    const length = itemList.length\n    const keyField = unref(idKey)\n    const map = new Map<Key, number>()\n\n    for (let i = 0; i < length; ++i) {\n      map.set(itemList[i][keyField], i)\n    }\n\n    return map\n  })\n  const visibleHeight = ref(0)\n  const heightDiffMap = new Map<Key, number>()\n  const heightTree = computed(() => {\n    const itemList = unref(items)\n    const length = itemList.length\n    const keyField = unref(idKey)\n    const tree = createBITree(length, unref(itemSize))\n\n    for (let i = 0; i < length; ++i) {\n      const key = itemList[i][keyField]\n      const heightDiff = heightDiffMap.get(key)\n\n      if (heightDiff) {\n        tree.add(i, heightDiff)\n      }\n    }\n\n    return tree\n  })\n  const treeUpdateDep = ref(0)\n  const scrollOffset = ref(0)\n  const startIndex = computed(() => {\n    return Math.max(\n      heightTree.value.boundIndex(scrollOffset.value) - Math.max(unref(bufferSize), 0),\n      0,\n    )\n  })\n  const visibleItems = computed(() => {\n    if (!visibleHeight.value || visibleHeight.value < 0) return []\n\n    const unrefItems = unref(items)\n    const endIndex = Math.min(\n      heightTree.value.boundIndex(scrollOffset.value + visibleHeight.value) +\n        1 +\n        Math.max(unref(bufferSize), 0),\n      unrefItems.length,\n    )\n\n    return unrefItems.slice(startIndex.value, endIndex)\n  })\n  const listStyle = computed(() => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    treeUpdateDep.value\n\n    const height = heightTree.value.sum()\n    const fixed = unref(itemFixed)\n\n    return {\n      height: fixed ? `${height}px` : undefined,\n      minHeight: fixed ? undefined : `${height}px`,\n      boxSizing: 'content-box',\n    } as const\n  })\n  const itemsStyle = computed(() => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    treeUpdateDep.value\n\n    return {\n      transform: `translate3d(0, ${heightTree.value.sum(startIndex.value)}px, 0)`,\n    }\n  })\n\n  watch(\n    () => unref(wrapper),\n    el => {\n      if (el && isDefined(defaultKeyAt)) {\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            scrollToKey(defaultKeyAt)\n          })\n        })\n      }\n    },\n    { immediate: true, flush: 'post' },\n  )\n\n  if (autoResize) {\n    let unobserve = noop\n\n    const stopWatch = watch(\n      () => [unref(wrapper), autoResize] as const,\n      ([el]) => {\n        unobserve()\n\n        if (!el) return\n\n        observeResize(el, handleResize)\n\n        unobserve = () => {\n          unobserveResize(el)\n          unobserve = noop\n        }\n\n        if (isDefined(defaultKeyAt)) {\n          scrollToKey(defaultKeyAt)\n        }\n      },\n      { immediate: true, flush: 'post' },\n    )\n\n    onScopeDispose(() => {\n      stopWatch()\n      unobserve()\n    })\n  }\n\n  function syncScrollOffset() {\n    const wrapperEl = unref(wrapper)\n\n    if (wrapperEl) {\n      scrollOffset.value = wrapperEl.scrollTop\n    }\n  }\n\n  function handleScroll() {\n    nextFrameOnce(syncScrollOffset)\n  }\n\n  function handleResize(entry: ResizeObserverEntry) {\n    if (\n      isHiddenElement(entry.target as HTMLElement) ||\n      entry.contentRect.height === visibleHeight.value\n    ) {\n      return\n    }\n\n    visibleHeight.value = entry.contentRect.height\n  }\n\n  function handleItemResize(key: Key, entry: ResizeObserverEntry) {\n    if (unref(itemFixed)) return\n\n    const index = indexMap.value.get(key)!\n    const tree = heightTree.value\n    const prevHeight = tree.get(index)\n    const height = entry.borderBoxSize?.[0]?.blockSize ?? entry.contentRect.height\n\n    if (height === prevHeight) return\n\n    if (isHiddenElement(entry.target as HTMLElement)) {\n      if (prevHeight) {\n        tree.add(index, -prevHeight)\n        treeUpdateDep.value++\n      }\n\n      return\n    }\n\n    const diff = height - unref(itemSize)\n    const delta = height - prevHeight\n\n    if (diff) {\n      heightDiffMap.set(key, diff)\n    } else {\n      heightDiffMap.delete(key)\n    }\n\n    if (!delta) return\n\n    tree.add(index, delta)\n    treeUpdateDep.value++\n\n    const wrapperEl = unref(wrapper)\n\n    if (wrapperEl) {\n      const prevTop = tree.sum(index)\n\n      if (wrapperEl.scrollTop > prevTop) {\n        wrapperEl.scrollBy(0, delta)\n      }\n\n      scrollOffset.value = wrapperEl.scrollTop\n    }\n  }\n\n  function scrollTo(top: number, behavior?: Behavior) {\n    const wrapperEl = unref(wrapper)\n\n    if (wrapperEl) {\n      wrapperEl.scrollTo({\n        behavior,\n        top,\n        left: 0,\n      })\n    }\n  }\n\n  function scrollBy(delta: number, behavior?: Behavior) {\n    const wrapperEl = unref(wrapper)\n\n    if (wrapperEl) {\n      wrapperEl.scrollBy({\n        behavior,\n        top: delta,\n        left: 0,\n      })\n    }\n  }\n\n  function scrollToKey(key: Key, behavior?: Behavior) {\n    const index = indexMap.value.get(key)\n\n    if (index != null) {\n      scrollToIndex(index, behavior)\n    }\n  }\n\n  function scrollToIndex(index: number, behavior?: Behavior) {\n    const wrapperEl = unref(wrapper)\n\n    if (wrapperEl) {\n      wrapperEl.scrollTo({\n        behavior,\n        top: heightTree.value.sum(index),\n        left: 0,\n      })\n    }\n  }\n\n  function ensureIndexInView(index: number, behavior?: Behavior) {\n    const wrapperEl = unref(wrapper)\n\n    if (!wrapperEl) return\n\n    const tree = heightTree.value\n    const viewTop = wrapperEl.scrollTop\n    const top = tree.sum(index)\n\n    if (top < viewTop) {\n      scrollToIndex(index, behavior)\n      return\n    }\n\n    const viewHeight = wrapperEl.offsetHeight\n    const viewBottom = viewTop + viewHeight\n    const bottom = tree.sum(index + 1)\n\n    if (bottom > viewBottom) {\n      scrollTo(bottom - viewHeight, behavior)\n    }\n  }\n\n  function ensureKeyInView(key: Key, behavior?: Behavior) {\n    const index = indexMap.value.get(key)\n\n    if (index != null) {\n      ensureIndexInView(index, behavior)\n    }\n  }\n\n  return {\n    wrapper,\n    indexMap,\n    heightTree,\n    startIndex,\n    scrollOffset,\n    visibleItems,\n    listStyle,\n    itemsStyle,\n    handleScroll,\n    handleResize,\n    handleItemResize,\n    scrollTo,\n    scrollBy,\n    scrollToKey,\n    scrollToIndex,\n    ensureIndexInView,\n    ensureKeyInView,\n  }\n}\n"],"names":["y","Ot","M","t","it","W","bt","Jn","e","a","d","Me","ve","tn","Pr","Br","ht","eo","Jt","D","te","gn","io","fo","useListener","target","event","listener","options","noop","normalizedOptions","computed","remove","stopWatch","watch","unref","el","disabled","opts","handler","stop","getCurrentScope","onScopeDispose","CLICK_OUTSIDE","elements","isClient","CLICK_TYPE","path","dispatchEvent","useClickOutside","ref","useDisplay","displayInit","element","observer","onMounted","nextTick","hiddenParentNode","queryOutsideHiddenElement","onBeforeUnmount","parentElement","isHiddenElement","createSlotRender","slots","names","fallback","name","params","renderSlot","vnodes","ensureArray","flatVNodes","children","result","loop","vnode","isVNode","Comment","createTextVNode","Fragment","unrefElement","plain","proxyExposed","_","key","_a","_b","_c","watchPauseable","args","active","handle","pause","resume","callbackArgs","resolve","reject","readonly","pickToRefs","reactive","keys","toRef","functionsMap","map","m","supported","notSupportedResult","states","subscriptions","ELEMENT","EVENT","state","full","useFullScreen","targetRef","isRef","REQUEST","EXIT","old","exit","enter","force","toggle","useHover","wrapper","isHover","enterWrapper","leaveWrapper","observerCache","spaceRE","unitRE","useIntersection","root","threshold","margin","normalizeMargin","thresholdCache","marginCache","handleIntersect","handlers","disconnect","parts","i","part","toNumber","entries","len","entry","useManualRef","updateSet","manualRef","value","customRef","track","trigger","origin","update","newValue","triggerUpdate","defaultAliasMap","separatorRE","splitRE","internalProps","useModifier","autoReset","capture","passive","strictTarget","onKeyDown","onKeyUp","aliasMap","activeKeys","metaDeps","modifier","resetAll","setModifier","updateModifier","modifierProxy","prop","receiver","useMounted","wait","isMounted","mount","disableEvent","useMoving","x","lazy","stopMouse","stopTouch","moving","internalState","current","record","throttleMove","throttle","updateState","start","move","end","clientX","clientY","xStart","yStart","clientXStart","clientYStart","deltaX","deltaY","registered","pageX","pageY","throttleHandler","register","unregister","usePointer","sides","min","max","round","floor","createCoords","v","oppositeSideMap","oppositeAlignmentMap","clamp","evaluate","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","length","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","getSideList","side","isStart","lr","rl","tb","getOppositeAxisPlacements","flipAlignment","direction","list","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","width","height","computeCoordsFromPlacement","_ref","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","computePosition","config","strategy","middleware","platform","validMiddleware","statefulPlacement","middlewareData","resetCount","fn","nextX","nextY","data","reset","detectOverflow","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","offsetParent","offsetScale","elementClientRect","arrow","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","detectOverflowOptions","initialSideAxis","isBasePlacement","fallbackPlacements","hasFallbackAxisSideDirection","placements","overflow","overflows","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","_overflowsData$","ignoreCrossAxisOverflow","hasInitialMainAxisOverflow","resetPlacement","b","_overflowsData$filter2","currentSideAxis","acc","getSideOffsets","isAnySideFullyClipped","hide","offsets","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","_middlewareData$offse","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","hasWindow","getNodeName","node","isNode","getWindow","_node$ownerDocument","getDocumentElement","isElement","isHTMLElement","isShadowRoot","isOverflowElement","overflowX","overflowY","display","getComputedStyle","isTableElement","isTopLayer","selector","isContainingBlock","elementOrCss","webkit","isWebKit","css","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","getNodeScroll","getNearestOverflowAncestor","parentNode","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","frameElement","getFrameElement","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","left","top","getWindowScrollBarX","leftScroll","getHTMLOffset","documentElement","scroll","ignoreScrollbarX","htmlRect","convertOffsetParentRelativeRectToViewportRelativeRect","topLayer","isOffsetParentAnElement","offsetRect","htmlOffset","getClientRects","getDocumentRect","html","body","getViewportRect","visualViewport","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","setLeftRTLScrollbarOffset","isStaticPositioned","getTrueOffsetParent","polyfill","rawOffsetParent","getOffsetParent","svgOffsetParent","getElementRects","getOffsetParentFn","getDimensionsFn","floatingDimensions","isRTL","rectsAreEqual","observeMove","onMove","timeoutId","cleanup","_io","refresh","skip","elementRectForRootMargin","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","ratio","autoUpdate","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","_resizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","offset$1","shift$1","flip$1","hide$1","arrow$1","mergedOptions","platformWithCache","computePosition$1","resizeObservers","hasActiveObservations","ro","hasSkippedObservations","msg","deliverResizeLoopError","ResizeObserverBoxOptions","freeze","obj","ResizeObserverSize","inlineSize","blockSize","DOMRectReadOnly","right","bottom","rectangle","isSVG","isHidden","scope","isReplacedElement","global","scrollRegexp","verticalRegexp","IE","parseDimension","pixel","size","switchSizes","zeroBoxes","calculateBoxSizes","forceRecalculation","cs","svg","removePadding","canScrollVertically","canScrollHorizontally","paddingTop","paddingRight","paddingBottom","paddingLeft","borderTop","borderRight","borderBottom","borderLeft","horizontalPadding","verticalPadding","horizontalBorderArea","verticalBorderArea","horizontalScrollbarThickness","verticalScrollbarThickness","widthReduction","heightReduction","contentWidth","contentHeight","borderBoxWidth","borderBoxHeight","boxes","calculateBoxSize","observedBox","borderBoxSize","contentBoxSize","devicePixelContentBoxSize","ResizeObserverEntry","calculateDepthForNode","depth","parent","broadcastActiveObservations","shallowestDepth","callbacks","ot","targetDepth","_i","callbacks_1","callback","gatherActiveObservationsAtDepth","process","notify","cb","queueMicroTask","toggle_1","el_1","queueResizeObserver","watching","isWatching","CATCH_PERIOD","observerConfig","events","time","timeout","scheduled","Scheduler","_this","until","elementsHaveResized","scheduler","updateCount","n","skipNotifyOnElement","ResizeObservation","ResizeObserverDetail","observerMap","getObservationIndex","observationTargets","ResizeObserverController","detail","firstObservation","index","lastObservation","ResizeObserver","handlerMap","handleResize","observeResize","unobserveResize","useResize","unobserve","computedRtl","elId","useRtl","initObserver","style","content","placementWhileList","usePopper","initOptions","transfer","isDrop","shallowRef","popper","arrowRef","transferTo","isRtl","watchEffect","wrapperEl","popperEl","setTransferTo","updatePopper","updatePopperInternal","arrowEl","setPopperDropOrigin","offsetOptions","shiftOptions","activePlacement","styleId","elClass","elCache","useTheme","theme","createObserver","activeThemes","themeWidths","prevStyle","rootClass","varsClass","addActiveThemes","themes","setActiveThemes","idCount","getElId","useSetTimeout","timer","useSetInterval","useRaf","useTimerRecord","interval","raf","useTriggerHandler","currentVisible","delay","handleTriggerEnter","handleTriggerLeave","handleTriggerClick","useVirtual","items","itemSize","itemFixed","idKey","defaultKeyAt","bufferSize","autoResize","indexMap","itemList","keyField","visibleHeight","heightDiffMap","heightTree","tree","createBITree","heightDiff","treeUpdateDep","scrollOffset","startIndex","visibleItems","unrefItems","endIndex","listStyle","fixed","itemsStyle","isDefined","scrollToKey","syncScrollOffset","handleScroll","nextFrameOnce","handleItemResize","prevHeight","diff","delta","prevTop","scrollTo","behavior","scrollBy","scrollToIndex","ensureIndexInView","viewTop","viewHeight","viewBottom","ensureKeyInView"],"mappings":"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","x_google_ignoreList":[13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39]}