import { computed as I, watch as Y, unref as E, getCurrentScope as Ee, onScopeDispose as Q, ref as z, onMounted as ot, nextTick as Nt, onBeforeUnmount as it, renderSlot as mn, isVNode as vn, Comment as pn, createTextVNode as gn, Fragment as bn, readonly as Wt, toRef as yn, isRef as ce, customRef as wn, reactive as Ke, shallowRef as qe, watchEffect as vt } from "vue";
const D = typeof window < "u";
var pt;
D && ((pt = window == null ? void 0 : window.navigator) != null && pt.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Be(e) {
  return e != null;
}
function P() {
}
const xn = Object.freeze({
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
});
Object.freeze(new Set(Object.keys(xn)));
function gt(e) {
  return e & -e;
}
function En(e, t = 0) {
  const n = new Array(e + 1).fill(0);
  function r(c, a) {
    if (!(!a || c >= e))
      for (c += 1; c <= e; )
        n[c] += a, c += gt(c);
  }
  function o(c = e) {
    if (c <= 0) return 0;
    c > e && (c = e);
    let a = c * t;
    for (; c > 0; )
      a += n[c], c -= gt(c);
    return a;
  }
  function i(c) {
    return o(c + 1) - o(c);
  }
  function s(c) {
    let a = 0, l = e;
    for (; l > a; ) {
      const f = Math.floor((a + l) / 2), d = o(f);
      if (d > c) {
        l = f;
        continue;
      } else if (d < c) {
        if (a === f)
          return o(a + 1) <= c ? a + 1 : a;
        a = f;
      } else
        return f;
    }
    return a;
  }
  return { tree: n, add: r, sum: o, get: i, boundIndex: s };
}
function Rn(e) {
  let t = parseFloat(e);
  return Number.isNaN(t) && (t = Number(e)), Number.isNaN(t) ? 0 : t;
}
const Tn = D && ("ontouchstart" in window || On() > 0), Sn = Tn ? "pointerdown" : "click";
function On() {
  return typeof navigator < "u" && (navigator.maxTouchPoints || navigator.msMaxTouchPoints) || 0;
}
function zn(e, t, n = window.Event) {
  const { type: r, bubbles: o = !1, cancelable: i = !1, ...s } = t;
  if (!Be(r) || r === "") return !1;
  let c;
  return Be(n) ? c = new n(r, { bubbles: o, cancelable: i }) : (c = document.createEvent("HTMLEvents"), c.initEvent(r, o, i)), Object.assign(c, s), e.dispatchEvent(c);
}
const kn = D ? requestAnimationFrame : (e) => {
  setTimeout(e, 16);
};
function It(e, t = 16) {
  if (typeof e != "function")
    return P;
  const n = (...i) => {
    e(...i);
  };
  if (t <= 0)
    return An(n);
  let r = 0, o;
  return function(...i) {
    const s = Date.now(), c = s - r;
    clearTimeout(o), c >= t ? (r = s, n(...i)) : o = setTimeout(
      () => {
        r = Date.now(), n(...i);
      },
      Math.max(0, t - c)
    );
  };
}
function An(e) {
  if (typeof e != "function")
    return e;
  let t = !1, n, r;
  return function(...o) {
    return n = o, t || (t = !0, r = Promise.resolve().then(() => (t = !1, r = void 0, e(...n)))), r;
  };
}
const pe = /* @__PURE__ */ new Set(), Ht = /* @__PURE__ */ new WeakMap();
function Cn() {
  pe.forEach((e) => {
    e(...Ht.get(e));
  }), pe.clear();
}
function Mn(e, ...t) {
  if (typeof e != "function")
    return e;
  Ht.set(e, t), !pe.has(e) && (pe.add(e), pe.size === 1 && kn(Cn));
}
function $t(e) {
  return Array.isArray(e) ? e : [e];
}
function J(e, t, n, r) {
  if (!e)
    return P;
  const o = I(() => typeof r == "boolean" ? { capture: r } : r || {});
  let i = P;
  const s = Y(
    () => E(e),
    (a) => {
      if (i(), !a)
        return;
      const { disabled: l, ...f } = o.value, d = (v) => {
        E(l) || n(v);
      };
      a.addEventListener(t, d, f), i = () => {
        a.removeEventListener(t, d, f), i = P;
      };
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    s(), i();
  };
  return Ee() && Q(c), c;
}
const qt = "clickoutside", Ue = /* @__PURE__ */ new Set();
D && document.addEventListener(
  Sn,
  (e) => {
    const t = e.target, n = e.composedPath && e.composedPath();
    Ue.forEach((r) => {
      r !== t && (n ? !n.includes(r) : !r.contains(t)) && (!r.__transferElement || r.__transferElement !== t && !r.__transferElement.contains(t)) && zn(r, { type: qt });
    });
  },
  !0
);
function oo(e, t = z(null)) {
  let n = P;
  const r = Y(
    () => E(t),
    (i) => {
      n(), i && (Ue.add(i), n = () => {
        Ue.delete(i), n = P;
      });
    },
    { immediate: !0, flush: "post" }
  ), o = () => {
    r(), n();
  };
  return Ee() && Q(o), J(t, qt, e), t;
}
function io(e = P, t = z(null)) {
  let n;
  return ot(() => {
    Nt(() => {
      const r = Vt(t.value);
      r ? (n = new MutationObserver(() => {
        r.style.display !== "none" && (typeof e == "function" && e(), n == null || n.disconnect(), n = null);
      }), n.observe(r, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        attributeFilter: ["style"]
      })) : typeof e == "function" && e();
    });
  }), it(() => {
    n == null || n.disconnect(), n = null;
  }), t;
}
function Vt(e) {
  if (e) {
    let t = e.parentElement;
    for (; t && t !== document.body; ) {
      if (t.style.display === "none")
        return t;
      t = t.parentElement;
    }
  }
  return null;
}
function bt(e) {
  return (e == null ? void 0 : e.style.display) !== "none" ? !!Vt(e) : !0;
}
function so(e, t, n) {
  for (const r of t)
    if (e[r])
      return (o) => mn(e, r, o, () => {
        const i = n == null ? void 0 : n(o);
        return i ? $t(i) : [];
      });
  return n || null;
}
function co(e) {
  const t = [], n = Array.isArray(e) ? [...e] : [];
  for (; n.length; ) {
    const r = n.shift();
    r !== null && (Array.isArray(r) && n.unshift(...r), !(typeof r != "string" && typeof r != "number" && (!vn(r) || r.type === pn)) && (typeof r == "string" || typeof r == "number" ? t.push(gn(String(r))) : r.type === bn && Array.isArray(r.children) ? n.unshift(r.children) : t.push(r)));
  }
  return t;
}
function Se(e) {
  const t = E(e);
  return typeof t == "string" ? D ? document.querySelector(t) : null : (t == null ? void 0 : t.$el) ?? t;
}
function ao(e) {
  return new Proxy({}, {
    get(t, n) {
      var r, o, i;
      if (e.component)
        return ((r = e.component.proxy) == null ? void 0 : r[n]) ?? ((o = e.component.exposeProxy) == null ? void 0 : o[n]) ?? ((i = e.component.exposed) == null ? void 0 : i[n]);
    }
  });
}
function lo(...e) {
  const t = z(!0), n = e[1] || P;
  function r() {
    t.value = !1;
  }
  function o() {
    t.value = !0;
  }
  const i = Y(
    e[0],
    (...s) => new Promise((c, a) => {
      t.value && Promise.resolve(n(...s)).then(c).catch(a);
    }),
    e[2]
  );
  return { active: Wt(t), pause: r, resume: o, stop: i };
}
function fo(e, t) {
  return t.map((n) => yn(e, n));
}
const Ln = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror"
  ],
  // New WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  // Old WebKit
  [
    "webkitRequestFullScreen",
    "webkitCancelFullScreen",
    "webkitCurrentFullScreenElement",
    "webkitCancelFullScreen",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror"
  ],
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError"
  ]
];
let ae;
if (D) {
  for (const e of Ln)
    if (e[1] in document) {
      ae = e;
      break;
    }
}
const Ge = !!ae, Bn = {
  supported: Ge,
  full: I(() => !1),
  enter: P,
  exit: P,
  toggle: P
}, Xt = /* @__PURE__ */ new Set(), Je = /* @__PURE__ */ new WeakMap();
if (D && ae) {
  const e = ae[2], t = ae[4];
  document.addEventListener(
    t,
    () => {
      if (Xt.forEach((n) => {
        n.value = !1;
      }), document[e]) {
        const n = Je.get(document[e]);
        n && (n.value = !0);
      }
    },
    !1
  );
}
function uo(e = z(null)) {
  const t = I({
    get: () => Se(e),
    set: (l) => {
      ce(e) && (e.value = l);
    }
  });
  if (!D || !Ge)
    return { ...Bn, target: t };
  const [n, r, o] = ae, i = z(!1);
  Y(
    () => Se(e),
    (l, f) => {
      f && Je.delete(f), l && Je.set(l, i);
    },
    { immediate: !0, flush: "post" }
  ), Xt.add(i), Ee() && Q(c);
  async function s(l = !1) {
    await c();
    const f = Se(e);
    return f && (l || !document[o]) ? (await f[n](), i.value = !0, document[o] === f) : !1;
  }
  async function c(l = !1) {
    const f = Se(e);
    return l || document[o] && document[o] === f ? (await document[r](), i.value = !1, document[o] !== f) : !1;
  }
  async function a(l = !1) {
    return i.value ? await c(l) : await s(l);
  }
  return {
    supported: Ge,
    target: t,
    full: I(() => i.value),
    enter: s,
    exit: c,
    toggle: a
  };
}
function ho(e = z(null)) {
  const t = z(!1);
  J(e, "mouseenter", n), J(e, "mouseleave", r);
  function n() {
    t.value = !0;
  }
  function r() {
    t.value = !1;
  }
  return { wrapper: e, isHover: t };
}
const Oe = /* @__PURE__ */ new WeakMap(), Pn = /\s+/g, Fn = /(px|%)$/;
function mo(e) {
  const t = e.target || z(null);
  if (!D)
    return { target: t, disconnect: P };
  const { handler: n } = e;
  let r = e.root ?? document;
  const o = $t(e.threshold || 0).join() || "0", i = m(e.rootMargin);
  Oe.has(r) || Oe.set(r, /* @__PURE__ */ new Map());
  const s = Oe.get(r);
  s.has(o) || s.set(o, /* @__PURE__ */ new Map());
  const c = s.get(o);
  c.has(i) || c.set(i, {
    ob: new IntersectionObserver(b, { ...e, rootMargin: i }),
    count: 0,
    handlers: /* @__PURE__ */ new WeakMap()
  });
  let a = c.get(i), { ob: l, handlers: f } = a, d = P;
  const v = Y(
    () => E(t),
    (p) => {
      d(), !(!p || !l) && (f.set(p, n), l.observe(p), a && a.count++, d = () => {
        l.unobserve(p), f.delete(p), a && a.count--, d = P;
      });
    },
    { immediate: !0, flush: "post" }
  );
  Ee() && Q(g);
  function m(p) {
    if (!p || !p.trim()) return "_";
    const h = p.trim().split(Pn, 4);
    h.length = 4;
    for (let u = 0; u < 4; ++u) {
      const y = h[u];
      h[u] = Fn.test(y) ? y : `${Rn(y)}px`;
    }
    return h.join(" ");
  }
  function b(p) {
    for (let h = 0, u = p.length; h < u; ++h) {
      const y = p[h], O = f.get(y.target);
      typeof O == "function" && O(y);
    }
  }
  function g() {
    v(), d(), a && (a.count <= 0 && (c.delete(i), c.size || (s.delete(o), s.size || Oe.delete(r))), a = void 0, l = void 0, f = void 0, r = void 0);
  }
  return { target: t, disconnect: g };
}
function vo() {
  const e = /* @__PURE__ */ new Set();
  function t(r) {
    return wn((o, i) => {
      let s = r;
      const c = () => {
        r !== s && (s = r, i());
      };
      return {
        get: () => (o(), r),
        set: (a) => {
          a !== r && (r = a, e.add(c));
        }
      };
    });
  }
  function n() {
    for (const r of e)
      r();
    e.clear();
  }
  return { updateSet: e, manualRef: t, triggerUpdate: n };
}
const Dn = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
}, _n = /[+_-]/, Nn = /[+_-]/g, Wn = ["activeKeys", "resetAll"];
function po(e = {}) {
  const {
    autoReset: t = !0,
    capture: n = !1,
    passive: r = !0,
    strictTarget: o = !1,
    onKeyDown: i = P,
    onKeyUp: s = P
  } = e, c = e.target || z(null), a = ce(e.disabled) ? e.disabled : z(e.disabled || !1), l = { ...Dn, ...e.aliasMap || {} }, f = Ke(/* @__PURE__ */ new Set()), d = /* @__PURE__ */ new Set(), v = Ke({ activeKeys: f, resetAll: g });
  function m(h, u) {
    h in v && (v[h] = u);
  }
  function b(h, u) {
    var S, C;
    const y = (S = h.key) == null ? void 0 : S.toLocaleLowerCase(), T = [(C = h.code) == null ? void 0 : C.toLocaleLowerCase(), y].filter(Boolean);
    for (const k of T)
      f[u ? "add" : "delete"](k), m(k, u);
    if (!u && y === "meta") {
      for (const k of d)
        f.delete(k), m(k, !1);
      d.clear();
    } else if (u && typeof h.getModifierState == "function" && h.getModifierState("Meta"))
      for (const k of [...f, ...T])
        d.add(k);
  }
  function g() {
    Object.keys(v).forEach((h) => {
      v[h] = !1;
    }), v.activeKeys = f, v.resetAll = g;
  }
  const p = new Proxy(v, {
    get(h, u, y) {
      if (typeof u != "string" || Wn.includes(u))
        return Reflect.get(h, u, y);
      if (u = u.toLocaleLowerCase(), u in l && (u = l[u]), !(u in v))
        if (_n.test(u)) {
          const O = u.split(Nn).map((T) => T.trim());
          v[u] = I(() => O.every((T) => E(p[T])));
        } else
          v[u] = z(f.has(u));
      return E(Reflect.get(h, u, y));
    }
  });
  return J(
    c,
    "keydown",
    (h) => {
      o && h.target !== E(c) || (b(h, !0), i(h, p));
    },
    { capture: n, passive: r, disabled: a }
  ), J(
    c,
    "keyup",
    (h) => {
      o && h.target !== E(c) || (b(h, !1), s(h, p));
    },
    { capture: n, passive: r, disabled: a }
  ), t && J(c, "blur", g, { capture: n, passive: r, disabled: a }), { target: c, modifier: p };
}
function go(e) {
  const t = z(!1), n = () => t.value = !0;
  return ot(() => {
    e === "tick" ? Nt(n) : e === "frame" ? requestAnimationFrame(n) : n();
  }), it(() => {
    t.value = !1;
  }), { isMounted: Wt(t) };
}
function Ve(e) {
  e.cancelable && (e.stopPropagation(), e.preventDefault());
}
function bo(e) {
  const t = e.target || z(null), n = ce(e.x) ? e.x : z(0), r = ce(e.y) ? e.y : z(0), o = ce(e.lazy) ? e.lazy : z(e.lazy || !1), i = ce(e.disabled) ? e.disabled : z(e.disabled || !1), { capture: s = !0, stopMouse: c = !0, stopTouch: a = !0 } = e, l = z(!1), f = {
    xStart: 0,
    yStart: 0,
    xEnd: 0,
    yEnd: 0,
    clientX: 0,
    clientY: 0,
    deltaX: 0,
    deltaY: 0,
    lazy: !1
  };
  let d = 0, v = 0;
  const m = It((u) => {
    var y;
    v < d || (h(u), f.lazy || (n.value = f.xEnd, r.value = f.yEnd), (y = e.onMove) == null || y.call(e, f, u));
  });
  function b(u) {
    var y;
    i.value || (Object.assign(f, {
      xStart: n.value,
      yStart: r.value,
      xEnd: n.value,
      yEnd: r.value,
      clientX: u.clientX,
      clientY: u.clientY,
      lazy: o.value
    }), ((y = e.onStart) == null ? void 0 : y.call(e, f, u)) !== !1 && (document.addEventListener("pointermove", g, { capture: s }), document.addEventListener("pointerup", p, { capture: s }), v = d, l.value = !0));
  }
  function g(u) {
    i.value || (Ve(u), m(u));
  }
  function p(u) {
    var y;
    document.removeEventListener("pointermove", g, { capture: s }), document.removeEventListener("pointerup", p, { capture: s }), !i.value && (h(u), f.lazy && (n.value = f.xEnd, r.value = f.yEnd), l.value = !1, ++d, (y = e.onEnd) == null || y.call(e, f, u));
  }
  function h(u) {
    const { clientX: y, clientY: O } = u, { xStart: T, yStart: S, clientX: C, clientY: k } = f, M = y - C, L = O - k;
    f.deltaX = M, f.deltaY = L, f.xEnd = T + M, f.yEnd = S + L;
  }
  return J(t, "pointerdown", b, { capture: s }), c && J(t, "mousedown", Ve, { capture: s }), a && J(t, "touchstart", Ve, { capture: s }), {
    target: t,
    moving: I(() => l.value),
    x: n,
    y: r,
    lazy: o,
    disabled: i
  };
}
const be = /* @__PURE__ */ new Set(), Z = /* @__PURE__ */ new Map();
Z.set("x", 0);
Z.set("y", 0);
function In(e) {
  const { pageX: t, pageY: n } = e;
  Z.set("x", t), Z.set("y", n), be.forEach((r) => {
    r.x.value = t, r.y.value = n;
  });
}
const jt = It(In);
function Hn(e) {
  !be.size && window && (Z.set("x", 0), Z.set("y", 0), window.addEventListener("pointermove", jt, { passive: !0 })), be.add(e);
}
function yt(e) {
  be.delete(e), !be.size && window && window.removeEventListener("pointermove", jt);
}
function yo(e = {}) {
  const t = z(e.x ?? Z.get("x")), n = z(e.y ?? Z.get("y")), r = { x: t, y: n };
  return Hn(r), e.manualStop || it(() => {
    yt(r);
  }), { ...r, unregister: () => yt(r) };
}
const $n = ["top", "right", "bottom", "left"], ue = Math.min, te = Math.max, Pe = Math.round, ze = Math.floor, j = (e) => ({
  x: e,
  y: e
}), qn = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Vn = {
  start: "end",
  end: "start"
};
function Qe(e, t, n) {
  return te(e, ue(t, n));
}
function he(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ie(e) {
  return e.split("-")[0];
}
function Re(e) {
  return e.split("-")[1];
}
function Yt(e) {
  return e === "x" ? "y" : "x";
}
function st(e) {
  return e === "y" ? "height" : "width";
}
function ne(e) {
  return ["top", "bottom"].includes(ie(e)) ? "y" : "x";
}
function ct(e) {
  return Yt(ne(e));
}
function Xn(e, t, n) {
  n === void 0 && (n = !1);
  const r = Re(e), o = ct(e), i = st(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (s = Fe(s)), [s, Fe(s)];
}
function jn(e) {
  const t = Fe(e);
  return [Ze(e), t, Ze(t)];
}
function Ze(e) {
  return e.replace(/start|end/g, (t) => Vn[t]);
}
function Yn(e, t, n) {
  const r = ["left", "right"], o = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : r : t ? r : o;
    case "left":
    case "right":
      return t ? i : s;
    default:
      return [];
  }
}
function Kn(e, t, n, r) {
  const o = Re(e);
  let i = Yn(ie(e), n === "start", r);
  return o && (i = i.map((s) => s + "-" + o), t && (i = i.concat(i.map(Ze)))), i;
}
function Fe(e) {
  return e.replace(/left|right|bottom|top/g, (t) => qn[t]);
}
function Un(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Kt(e) {
  return typeof e != "number" ? Un(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function De(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function wt(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const i = ne(t), s = ct(t), c = st(s), a = ie(t), l = i === "y", f = r.x + r.width / 2 - o.width / 2, d = r.y + r.height / 2 - o.height / 2, v = r[c] / 2 - o[c] / 2;
  let m;
  switch (a) {
    case "top":
      m = {
        x: f,
        y: r.y - o.height
      };
      break;
    case "bottom":
      m = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      m = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      m = {
        x: r.x - o.width,
        y: d
      };
      break;
    default:
      m = {
        x: r.x,
        y: r.y
      };
  }
  switch (Re(t)) {
    case "start":
      m[s] -= v * (n && l ? -1 : 1);
      break;
    case "end":
      m[s] += v * (n && l ? -1 : 1);
      break;
  }
  return m;
}
const Gn = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: s
  } = n, c = i.filter(Boolean), a = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let l = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: f,
    y: d
  } = wt(l, r, a), v = r, m = {}, b = 0;
  for (let g = 0; g < c.length; g++) {
    const {
      name: p,
      fn: h
    } = c[g], {
      x: u,
      y,
      data: O,
      reset: T
    } = await h({
      x: f,
      y: d,
      initialPlacement: r,
      placement: v,
      strategy: o,
      middlewareData: m,
      rects: l,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    f = u ?? f, d = y ?? d, m = {
      ...m,
      [p]: {
        ...m[p],
        ...O
      }
    }, T && b <= 50 && (b++, typeof T == "object" && (T.placement && (v = T.placement), T.rects && (l = T.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : T.rects), {
      x: f,
      y: d
    } = wt(l, v, a)), g = -1);
  }
  return {
    x: f,
    y: d,
    placement: v,
    strategy: o,
    middlewareData: m
  };
};
async function _e(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: s,
    elements: c,
    strategy: a
  } = e, {
    boundary: l = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: d = "floating",
    altBoundary: v = !1,
    padding: m = 0
  } = he(t, e), b = Kt(m), p = c[v ? d === "floating" ? "reference" : "floating" : d], h = De(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(p))) == null || n ? p : p.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(c.floating)),
    boundary: l,
    rootBoundary: f,
    strategy: a
  })), u = d === "floating" ? {
    x: r,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, y = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c.floating)), O = await (i.isElement == null ? void 0 : i.isElement(y)) ? await (i.getScale == null ? void 0 : i.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, T = De(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: u,
    offsetParent: y,
    strategy: a
  }) : u);
  return {
    top: (h.top - T.top + b.top) / O.y,
    bottom: (T.bottom - h.bottom + b.bottom) / O.y,
    left: (h.left - T.left + b.left) / O.x,
    right: (T.right - h.right + b.right) / O.x
  };
}
const Jn = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i,
      platform: s,
      elements: c,
      middlewareData: a
    } = t, {
      element: l,
      padding: f = 0
    } = he(e, t) || {};
    if (l == null)
      return {};
    const d = Kt(f), v = {
      x: n,
      y: r
    }, m = ct(o), b = st(m), g = await s.getDimensions(l), p = m === "y", h = p ? "top" : "left", u = p ? "bottom" : "right", y = p ? "clientHeight" : "clientWidth", O = i.reference[b] + i.reference[m] - v[m] - i.floating[b], T = v[m] - i.reference[m], S = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l));
    let C = S ? S[y] : 0;
    (!C || !await (s.isElement == null ? void 0 : s.isElement(S))) && (C = c.floating[y] || i.floating[b]);
    const k = O / 2 - T / 2, M = C / 2 - g[b] / 2 - 1, L = ue(d[h], M), $ = ue(d[u], M), _ = L, w = C - g[b] - $, R = C / 2 - g[b] / 2 + k, x = Qe(_, R, w), B = !a.arrow && Re(o) != null && R !== x && i.reference[b] / 2 - (R < _ ? L : $) - g[b] / 2 < 0, A = B ? R < _ ? R - _ : R - w : 0;
    return {
      [m]: v[m] + A,
      data: {
        [m]: x,
        centerOffset: R - x - A,
        ...B && {
          alignmentOffset: A
        }
      },
      reset: B
    };
  }
}), Qn = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: s,
        initialPlacement: c,
        platform: a,
        elements: l
      } = t, {
        mainAxis: f = !0,
        crossAxis: d = !0,
        fallbackPlacements: v,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: g = !0,
        ...p
      } = he(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const h = ie(o), u = ne(c), y = ie(c) === c, O = await (a.isRTL == null ? void 0 : a.isRTL(l.floating)), T = v || (y || !g ? [Fe(c)] : jn(c)), S = b !== "none";
      !v && S && T.push(...Kn(c, g, b, O));
      const C = [c, ...T], k = await _e(t, p), M = [];
      let L = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (f && M.push(k[h]), d) {
        const x = Xn(o, s, O);
        M.push(k[x[0]], k[x[1]]);
      }
      if (L = [...L, {
        placement: o,
        overflows: M
      }], !M.every((x) => x <= 0)) {
        var $, _;
        const x = ((($ = i.flip) == null ? void 0 : $.index) || 0) + 1, B = C[x];
        if (B) {
          var w;
          const N = d === "alignment" ? u !== ne(B) : !1, F = ((w = L[0]) == null ? void 0 : w.overflows[0]) > 0;
          if (!N || F)
            return {
              data: {
                index: x,
                overflows: L
              },
              reset: {
                placement: B
              }
            };
        }
        let A = (_ = L.filter((N) => N.overflows[0] <= 0).sort((N, F) => N.overflows[1] - F.overflows[1])[0]) == null ? void 0 : _.placement;
        if (!A)
          switch (m) {
            case "bestFit": {
              var R;
              const N = (R = L.filter((F) => {
                if (S) {
                  const W = ne(F.placement);
                  return W === u || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  W === "y";
                }
                return !0;
              }).map((F) => [F.placement, F.overflows.filter((W) => W > 0).reduce((W, G) => W + G, 0)]).sort((F, W) => F[1] - W[1])[0]) == null ? void 0 : R[0];
              N && (A = N);
              break;
            }
            case "initialPlacement":
              A = c;
              break;
          }
        if (o !== A)
          return {
            reset: {
              placement: A
            }
          };
      }
      return {};
    }
  };
};
function xt(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Et(e) {
  return $n.some((t) => e[t] >= 0);
}
const Zn = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = he(e, t);
      switch (r) {
        case "referenceHidden": {
          const i = await _e(t, {
            ...o,
            elementContext: "reference"
          }), s = xt(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: Et(s)
            }
          };
        }
        case "escaped": {
          const i = await _e(t, {
            ...o,
            altBoundary: !0
          }), s = xt(i, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: Et(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function er(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s = ie(n), c = Re(n), a = ne(n) === "y", l = ["left", "top"].includes(s) ? -1 : 1, f = i && a ? -1 : 1, d = he(t, e);
  let {
    mainAxis: v,
    crossAxis: m,
    alignmentAxis: b
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return c && typeof b == "number" && (m = c === "end" ? b * -1 : b), a ? {
    x: m * f,
    y: v * l
  } : {
    x: v * l,
    y: m * f
  };
}
const tr = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: i,
        placement: s,
        middlewareData: c
      } = t, a = await er(t, e);
      return s === ((n = c.offset) == null ? void 0 : n.placement) && (r = c.arrow) != null && r.alignmentOffset ? {} : {
        x: o + a.x,
        y: i + a.y,
        data: {
          ...a,
          placement: s
        }
      };
    }
  };
}, nr = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: c = {
          fn: (p) => {
            let {
              x: h,
              y: u
            } = p;
            return {
              x: h,
              y: u
            };
          }
        },
        ...a
      } = he(e, t), l = {
        x: n,
        y: r
      }, f = await _e(t, a), d = ne(ie(o)), v = Yt(d);
      let m = l[v], b = l[d];
      if (i) {
        const p = v === "y" ? "top" : "left", h = v === "y" ? "bottom" : "right", u = m + f[p], y = m - f[h];
        m = Qe(u, m, y);
      }
      if (s) {
        const p = d === "y" ? "top" : "left", h = d === "y" ? "bottom" : "right", u = b + f[p], y = b - f[h];
        b = Qe(u, b, y);
      }
      const g = c.fn({
        ...t,
        [v]: m,
        [d]: b
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - r,
          enabled: {
            [v]: i,
            [d]: s
          }
        }
      };
    }
  };
};
function Ie() {
  return typeof window < "u";
}
function me(e) {
  return Ut(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function H(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function U(e) {
  var t;
  return (t = (Ut(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Ut(e) {
  return Ie() ? e instanceof Node || e instanceof H(e).Node : !1;
}
function q(e) {
  return Ie() ? e instanceof Element || e instanceof H(e).Element : !1;
}
function K(e) {
  return Ie() ? e instanceof HTMLElement || e instanceof H(e).HTMLElement : !1;
}
function Rt(e) {
  return !Ie() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof H(e).ShadowRoot;
}
function Te(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = V(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o);
}
function rr(e) {
  return ["table", "td", "th"].includes(me(e));
}
function He(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function at(e) {
  const t = lt(), n = q(e) ? V(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function or(e) {
  let t = ee(e);
  for (; K(t) && !de(t); ) {
    if (at(t))
      return t;
    if (He(t))
      return null;
    t = ee(t);
  }
  return null;
}
function lt() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function de(e) {
  return ["html", "body", "#document"].includes(me(e));
}
function V(e) {
  return H(e).getComputedStyle(e);
}
function $e(e) {
  return q(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function ee(e) {
  if (me(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Rt(e) && e.host || // Fallback.
    U(e)
  );
  return Rt(t) ? t.host : t;
}
function Gt(e) {
  const t = ee(e);
  return de(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : K(t) && Te(t) ? t : Gt(t);
}
function ye(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = Gt(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), s = H(o);
  if (i) {
    const c = et(s);
    return t.concat(s, s.visualViewport || [], Te(o) ? o : [], c && n ? ye(c) : []);
  }
  return t.concat(o, ye(o, [], n));
}
function et(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function Jt(e) {
  const t = V(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = K(e), i = o ? e.offsetWidth : n, s = o ? e.offsetHeight : r, c = Pe(n) !== i || Pe(r) !== s;
  return c && (n = i, r = s), {
    width: n,
    height: r,
    $: c
  };
}
function ft(e) {
  return q(e) ? e : e.contextElement;
}
function le(e) {
  const t = ft(e);
  if (!K(t))
    return j(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = Jt(t);
  let s = (i ? Pe(n.width) : n.width) / r, c = (i ? Pe(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const ir = /* @__PURE__ */ j(0);
function Qt(e) {
  const t = H(e);
  return !lt() || !t.visualViewport ? ir : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function sr(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== H(e) ? !1 : t;
}
function se(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), i = ft(e);
  let s = j(1);
  t && (r ? q(r) && (s = le(r)) : s = le(e));
  const c = sr(i, n, r) ? Qt(i) : j(0);
  let a = (o.left + c.x) / s.x, l = (o.top + c.y) / s.y, f = o.width / s.x, d = o.height / s.y;
  if (i) {
    const v = H(i), m = r && q(r) ? H(r) : r;
    let b = v, g = et(b);
    for (; g && r && m !== b; ) {
      const p = le(g), h = g.getBoundingClientRect(), u = V(g), y = h.left + (g.clientLeft + parseFloat(u.paddingLeft)) * p.x, O = h.top + (g.clientTop + parseFloat(u.paddingTop)) * p.y;
      a *= p.x, l *= p.y, f *= p.x, d *= p.y, a += y, l += O, b = H(g), g = et(b);
    }
  }
  return De({
    width: f,
    height: d,
    x: a,
    y: l
  });
}
function ut(e, t) {
  const n = $e(e).scrollLeft;
  return t ? t.left + n : se(U(e)).left + n;
}
function Zt(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    ut(e, r)
  )), i = r.top + t.scrollTop;
  return {
    x: o,
    y: i
  };
}
function cr(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const i = o === "fixed", s = U(r), c = t ? He(t.floating) : !1;
  if (r === s || c && i)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = j(1);
  const f = j(0), d = K(r);
  if ((d || !d && !i) && ((me(r) !== "body" || Te(s)) && (a = $e(r)), K(r))) {
    const m = se(r);
    l = le(r), f.x = m.x + r.clientLeft, f.y = m.y + r.clientTop;
  }
  const v = s && !d && !i ? Zt(s, a, !0) : j(0);
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - a.scrollLeft * l.x + f.x + v.x,
    y: n.y * l.y - a.scrollTop * l.y + f.y + v.y
  };
}
function ar(e) {
  return Array.from(e.getClientRects());
}
function lr(e) {
  const t = U(e), n = $e(e), r = e.ownerDocument.body, o = te(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = te(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + ut(e);
  const c = -n.scrollTop;
  return V(r).direction === "rtl" && (s += te(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: s,
    y: c
  };
}
function fr(e, t) {
  const n = H(e), r = U(e), o = n.visualViewport;
  let i = r.clientWidth, s = r.clientHeight, c = 0, a = 0;
  if (o) {
    i = o.width, s = o.height;
    const l = lt();
    (!l || l && t === "fixed") && (c = o.offsetLeft, a = o.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: c,
    y: a
  };
}
function ur(e, t) {
  const n = se(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i = K(e) ? le(e) : j(1), s = e.clientWidth * i.x, c = e.clientHeight * i.y, a = o * i.x, l = r * i.y;
  return {
    width: s,
    height: c,
    x: a,
    y: l
  };
}
function Tt(e, t, n) {
  let r;
  if (t === "viewport")
    r = fr(e, n);
  else if (t === "document")
    r = lr(U(e));
  else if (q(t))
    r = ur(t, n);
  else {
    const o = Qt(e);
    r = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return De(r);
}
function en(e, t) {
  const n = ee(e);
  return n === t || !q(n) || de(n) ? !1 : V(n).position === "fixed" || en(n, t);
}
function dr(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = ye(e, [], !1).filter((c) => q(c) && me(c) !== "body"), o = null;
  const i = V(e).position === "fixed";
  let s = i ? ee(e) : e;
  for (; q(s) && !de(s); ) {
    const c = V(s), a = at(s);
    !a && c.position === "fixed" && (o = null), (i ? !a && !o : !a && c.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || Te(s) && !a && en(e, s)) ? r = r.filter((f) => f !== s) : o = c, s = ee(s);
  }
  return t.set(e, r), r;
}
function hr(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const s = [...n === "clippingAncestors" ? He(t) ? [] : dr(t, this._c) : [].concat(n), r], c = s[0], a = s.reduce((l, f) => {
    const d = Tt(t, f, o);
    return l.top = te(d.top, l.top), l.right = ue(d.right, l.right), l.bottom = ue(d.bottom, l.bottom), l.left = te(d.left, l.left), l;
  }, Tt(t, c, o));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function mr(e) {
  const {
    width: t,
    height: n
  } = Jt(e);
  return {
    width: t,
    height: n
  };
}
function vr(e, t, n) {
  const r = K(t), o = U(t), i = n === "fixed", s = se(e, !0, i, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = j(0);
  function l() {
    a.x = ut(o);
  }
  if (r || !r && !i)
    if ((me(t) !== "body" || Te(o)) && (c = $e(t)), r) {
      const m = se(t, !0, i, t);
      a.x = m.x + t.clientLeft, a.y = m.y + t.clientTop;
    } else o && l();
  i && !r && o && l();
  const f = o && !r && !i ? Zt(o, c) : j(0), d = s.left + c.scrollLeft - a.x - f.x, v = s.top + c.scrollTop - a.y - f.y;
  return {
    x: d,
    y: v,
    width: s.width,
    height: s.height
  };
}
function Xe(e) {
  return V(e).position === "static";
}
function St(e, t) {
  if (!K(e) || V(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return U(e) === n && (n = n.ownerDocument.body), n;
}
function tn(e, t) {
  const n = H(e);
  if (He(e))
    return n;
  if (!K(e)) {
    let o = ee(e);
    for (; o && !de(o); ) {
      if (q(o) && !Xe(o))
        return o;
      o = ee(o);
    }
    return n;
  }
  let r = St(e, t);
  for (; r && rr(r) && Xe(r); )
    r = St(r, t);
  return r && de(r) && Xe(r) && !at(r) ? n : r || or(e) || n;
}
const pr = async function(e) {
  const t = this.getOffsetParent || tn, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: vr(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function gr(e) {
  return V(e).direction === "rtl";
}
const nn = {
  convertOffsetParentRelativeRectToViewportRelativeRect: cr,
  getDocumentElement: U,
  getClippingRect: hr,
  getOffsetParent: tn,
  getElementRects: pr,
  getClientRects: ar,
  getDimensions: mr,
  getScale: le,
  isElement: q,
  isRTL: gr
};
function rn(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function br(e, t) {
  let n = null, r;
  const o = U(e);
  function i() {
    var c;
    clearTimeout(r), (c = n) == null || c.disconnect(), n = null;
  }
  function s(c, a) {
    c === void 0 && (c = !1), a === void 0 && (a = 1), i();
    const l = e.getBoundingClientRect(), {
      left: f,
      top: d,
      width: v,
      height: m
    } = l;
    if (c || t(), !v || !m)
      return;
    const b = ze(d), g = ze(o.clientWidth - (f + v)), p = ze(o.clientHeight - (d + m)), h = ze(f), y = {
      rootMargin: -b + "px " + -g + "px " + -p + "px " + -h + "px",
      threshold: te(0, ue(1, a)) || 1
    };
    let O = !0;
    function T(S) {
      const C = S[0].intersectionRatio;
      if (C !== a) {
        if (!O)
          return s();
        C ? s(!1, C) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      C === 1 && !rn(l, e.getBoundingClientRect()) && s(), O = !1;
    }
    try {
      n = new IntersectionObserver(T, {
        ...y,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(T, y);
    }
    n.observe(e);
  }
  return s(!0), i;
}
function yr(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = r, l = ft(e), f = o || i ? [...l ? ye(l) : [], ...ye(t)] : [];
  f.forEach((h) => {
    o && h.addEventListener("scroll", n, {
      passive: !0
    }), i && h.addEventListener("resize", n);
  });
  const d = l && c ? br(l, n) : null;
  let v = -1, m = null;
  s && (m = new ResizeObserver((h) => {
    let [u] = h;
    u && u.target === l && m && (m.unobserve(t), cancelAnimationFrame(v), v = requestAnimationFrame(() => {
      var y;
      (y = m) == null || y.observe(t);
    })), n();
  }), l && !a && m.observe(l), m.observe(t));
  let b, g = a ? se(e) : null;
  a && p();
  function p() {
    const h = se(e);
    g && !rn(g, h) && n(), g = h, b = requestAnimationFrame(p);
  }
  return n(), () => {
    var h;
    f.forEach((u) => {
      o && u.removeEventListener("scroll", n), i && u.removeEventListener("resize", n);
    }), d == null || d(), (h = m) == null || h.disconnect(), m = null, a && cancelAnimationFrame(b);
  };
}
const wr = tr, xr = nr, Er = Qn, Rr = Zn, Tr = Jn, Sr = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: nn,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return Gn(e, t, {
    ...o,
    platform: i
  });
};
var re = [], Or = function() {
  return re.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, zr = function() {
  return re.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, Ot = "ResizeObserver loop completed with undelivered notifications.", kr = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: Ot
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = Ot), window.dispatchEvent(e);
}, we;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(we || (we = {}));
var oe = function(e) {
  return Object.freeze(e);
}, Ar = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, oe(this);
  }
  return e;
}(), on = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, oe(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, c = t.left, a = t.width, l = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: c, width: a, height: l };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), dt = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, sn = function(e) {
  if (dt(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, s = o.offsetHeight;
  return !(i || s || e.getClientRects().length);
}, zt = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, Cr = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ge = typeof window < "u" ? window : {}, ke = /* @__PURE__ */ new WeakMap(), kt = /auto|scroll/, Mr = /^tb|vertical/, Lr = /msie|trident/i.test(ge.navigator && ge.navigator.userAgent), X = function(e) {
  return parseFloat(e || "0");
}, fe = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Ar((n ? t : e) || 0, (n ? e : t) || 0);
}, At = oe({
  devicePixelContentBoxSize: fe(),
  borderBoxSize: fe(),
  contentBoxSize: fe(),
  contentRect: new on(0, 0, 0, 0)
}), cn = function(e, t) {
  if (t === void 0 && (t = !1), ke.has(e) && !t)
    return ke.get(e);
  if (sn(e))
    return ke.set(e, At), At;
  var n = getComputedStyle(e), r = dt(e) && e.ownerSVGElement && e.getBBox(), o = !Lr && n.boxSizing === "border-box", i = Mr.test(n.writingMode || ""), s = !r && kt.test(n.overflowY || ""), c = !r && kt.test(n.overflowX || ""), a = r ? 0 : X(n.paddingTop), l = r ? 0 : X(n.paddingRight), f = r ? 0 : X(n.paddingBottom), d = r ? 0 : X(n.paddingLeft), v = r ? 0 : X(n.borderTopWidth), m = r ? 0 : X(n.borderRightWidth), b = r ? 0 : X(n.borderBottomWidth), g = r ? 0 : X(n.borderLeftWidth), p = d + l, h = a + f, u = g + m, y = v + b, O = c ? e.offsetHeight - y - e.clientHeight : 0, T = s ? e.offsetWidth - u - e.clientWidth : 0, S = o ? p + u : 0, C = o ? h + y : 0, k = r ? r.width : X(n.width) - S - T, M = r ? r.height : X(n.height) - C - O, L = k + p + T + u, $ = M + h + O + y, _ = oe({
    devicePixelContentBoxSize: fe(Math.round(k * devicePixelRatio), Math.round(M * devicePixelRatio), i),
    borderBoxSize: fe(L, $, i),
    contentBoxSize: fe(k, M, i),
    contentRect: new on(d, a, k, M)
  });
  return ke.set(e, _), _;
}, an = function(e, t, n) {
  var r = cn(e, n), o = r.borderBoxSize, i = r.contentBoxSize, s = r.devicePixelContentBoxSize;
  switch (t) {
    case we.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case we.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, Br = /* @__PURE__ */ function() {
  function e(t) {
    var n = cn(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = oe([n.borderBoxSize]), this.contentBoxSize = oe([n.contentBoxSize]), this.devicePixelContentBoxSize = oe([n.devicePixelContentBoxSize]);
  }
  return e;
}(), ln = function(e) {
  if (sn(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Pr = function() {
  var e = 1 / 0, t = [];
  re.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var c = [];
      s.activeTargets.forEach(function(l) {
        var f = new Br(l.target), d = ln(l.target);
        c.push(f), l.lastReportedSize = an(l.target, l.observedBox), d < e && (e = d);
      }), t.push(function() {
        s.callback.call(s.observer, c, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, Ct = function(e) {
  re.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (ln(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, Fr = function() {
  var e = 0;
  for (Ct(e); Or(); )
    e = Pr(), Ct(e);
  return zr() && kr(), e > 0;
}, je, fn = [], Dr = function() {
  return fn.splice(0).forEach(function(e) {
    return e();
  });
}, _r = function(e) {
  if (!je) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return Dr();
    }).observe(n, r), je = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  fn.push(e), je();
}, Nr = function(e) {
  _r(function() {
    requestAnimationFrame(e);
  });
}, Me = 0, Wr = function() {
  return !!Me;
}, Ir = 250, Hr = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, Mt = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], Lt = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Ye = !1, $r = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Ir), !Ye) {
      Ye = !0;
      var r = Lt(t);
      Nr(function() {
        var o = !1;
        try {
          o = Fr();
        } finally {
          if (Ye = !1, t = r - Lt(), !Wr())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, Hr);
    };
    document.body ? n() : ge.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), Mt.forEach(function(n) {
      return ge.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), Mt.forEach(function(n) {
      return ge.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), tt = new $r(), Bt = function(e) {
  !Me && e > 0 && tt.start(), Me += e, !Me && tt.stop();
}, qr = function(e) {
  return !dt(e) && !Cr(e) && getComputedStyle(e).display === "inline";
}, Vr = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || we.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = an(this.target, this.observedBox, !0);
    return qr(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Xr = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Ae = /* @__PURE__ */ new WeakMap(), Pt = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Ce = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new Xr(t, n);
    Ae.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = Ae.get(t), i = o.observationTargets.length === 0;
    Pt(o.observationTargets, n) < 0 && (i && re.push(o), o.observationTargets.push(new Vr(n, r && r.box)), Bt(1), tt.schedule());
  }, e.unobserve = function(t, n) {
    var r = Ae.get(t), o = Pt(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && re.splice(re.indexOf(r), 1), r.observationTargets.splice(o, 1), Bt(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Ae.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), Ft = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Ce.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!zt(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Ce.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!zt(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Ce.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Ce.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const Ne = /* @__PURE__ */ new WeakMap();
function jr(e) {
  var t;
  for (let n = 0, r = e.length; n < r; ++n) {
    const o = e[n], i = Ne.get(o.target);
    if (typeof i == "function") {
      const { inlineSize: s, blockSize: c } = ((t = o.borderBoxSize) == null ? void 0 : t[0]) ?? {}, { offsetWidth: a, offsetHeight: l } = o.target;
      i(
        Object.assign(o, {
          offsetWidth: a,
          offsetHeight: l,
          width: s ?? a,
          height: c ?? l
        })
      );
    }
  }
}
const un = new (D && window.ResizeObserver || Ft)(
  jr
);
function xe(e, t) {
  Ne.set(e, t), un.observe(e);
}
function nt(e) {
  Ne.has(e) && (un.unobserve(e), Ne.delete(e));
}
function wo(e = {}) {
  let t = P;
  const n = Y(
    () => E(e.target),
    (o) => {
      t(), !(!o || typeof e.onResize != "function") && (xe(o, e.onResize), t = () => {
        nt(o), t = P;
      });
    },
    { immediate: !0 }
  ), r = () => {
    n(), t();
  };
  return Ee() && Q(r), {
    /**
     * @deprecated Will be removed in next major version, please directly use `observeResize` from imports.
     */
    observeResize: xe,
    /**
     * @deprecated Will be removed in next major version, please directly use `unobserveResize` from imports.
     */
    unobserveResize: nt,
    unobserve: r
  };
}
const dn = z(!1), Yr = I(() => dn.value), ve = "__rtl_observer__";
function Kr() {
  return D && !document.querySelector(`#${ve}`) && Ur(), { isRtl: Yr };
}
function Ur() {
  if (!D) return;
  const e = document.createElement("style"), t = `#${ve} { width: 1px } html.rtl #${ve}, html[dir='rtl'] #${ve} { width: 2px }`;
  e.textContent = t, document.head.appendChild(e);
  const n = document.createElement("div");
  n.id = ve, n.role = "none", n.style.cssText = "position: fixed; top -10px; left: -10px; height: 1px; visibility: hidden;", xe(n, () => {
    D && (dn.value = document.documentElement.classList.contains("rtl") || document.documentElement.getAttribute("dir") === "rtl");
  }), document.body.appendChild(n);
}
const xo = Object.freeze([
  "top",
  "top-start",
  "top-end",
  "bottom",
  "bottom-start",
  "bottom-end",
  "left",
  "left-start",
  "left-end",
  "right",
  "right-start",
  "right-end"
]);
function Eo(e) {
  const { transfer: t, wrapper: n, isDrop: r = !1 } = e, o = e.reference ?? qe(null), i = e.popper ?? qe(null), s = e.arrow ?? qe(null), c = z(E(e.placement)), a = z(""), l = e.isRtl ?? Kr().isRtl;
  n && vt(() => {
    const g = E(n), p = E(i);
    g && (g.__transferElement = p);
  }), t != null && (Y(
    () => E(t),
    (g) => {
      m(g), v();
    }
  ), m(E(t))), ot(() => {
    requestAnimationFrame(() => {
      vt(d);
    });
  });
  let f;
  async function d() {
    if (!D) return;
    f == null || f();
    const g = E(o), p = E(i);
    if (!g || !p) return;
    const h = E(s), u = [Er()];
    if (r && u.push({
      name: "origin",
      fn({ placement: S, elements: C }) {
        const k = b(S);
        return k && (C.floating.style.transformOrigin = k), {};
      }
    }), e.offset) {
      let S = E(e.offset);
      Array.isArray(S) && (S = {
        mainAxis: S[1],
        crossAxis: S[0]
      }), u.push(wr(S));
    }
    if (e.shift) {
      let S = E(e.shift);
      typeof S == "boolean" && (S = {}), u.push(xr(S));
    }
    h && u.push(Tr({ element: h })), u.push(Rr({ strategy: "escaped" }));
    const y = E(l) || !1, O = {
      middleware: u,
      placement: E(e.placement),
      platform: {
        ...nn,
        isRTL: async () => y
      }
    }, T = async () => {
      const {
        x: S,
        y: C,
        placement: k,
        strategy: M,
        middlewareData: L
      } = await Sr(g, p, O);
      if (E(o) !== g) {
        E(i) === p && Object.assign(p.style, {
          position: "",
          top: "",
          left: ""
        });
        return;
      }
      const $ = {
        position: M,
        top: `${C}px`,
        left: `${S}px`
      };
      if (h)
        if (L.arrow) {
          const { x: _, y: w } = L.arrow;
          Object.assign(h.style, {
            top: w != null ? `${w}px` : "",
            left: _ != null ? `${_}px` : ""
          });
        } else
          Object.assign(h.style, { top: "", left: "" });
      Object.assign(p.style, $), p.dataset.popperPlacement = k, c.value = k;
    };
    e.autoUpdate && (f = yr(g, p, T)), await T();
  }
  const v = () => new Promise((g) => {
    requestAnimationFrame(() => {
      d().then(g);
    });
  });
  function m(g) {
    a.value = typeof g == "boolean" ? g ? "body" : "" : g;
  }
  function b(g) {
    if (g !== "left" && g !== "right") {
      const [p, h] = g.split("-");
      return p === "bottom" || p !== "top" && h === "start" ? "center top" : "center bottom";
    }
  }
  return {
    wrapper: n,
    reference: o,
    popper: i,
    placement: c,
    transferTo: a,
    updatePopper: v
  };
}
const Dt = "__theme_style__", Le = "__theme_observer__", _t = /* @__PURE__ */ new WeakMap();
function Ro(e) {
  const t = z();
  if (D) {
    e = e || document.body;
    let n = _t.get(e);
    n || (n = Zr(t), e.appendChild(n), _t.set(e, n));
  }
  return { theme: t };
}
const We = Ke(/* @__PURE__ */ new Map()), rt = /* @__PURE__ */ new Map();
Y(We, () => {
  if (!D) return;
  rt.clear();
  const e = document.head.querySelector(`#${Dt}`);
  e && document.head.removeChild(e);
  const t = document.createElement("style");
  let n = `.${Le} { width: 1px }`, r = 1;
  for (const [o, [i, s]] of We.entries())
    n += ` html.${i} .${Le}, .${s} .${Le} { width: ${++r}px }`, rt.set(r, o);
  t.textContent = n, t.id = Dt, document.head.appendChild(t);
});
function Gr(e) {
  for (const t of e) {
    const {
      name: n,
      rootClass: r = n,
      varsClass: o = `vxp-theme-vars-${r}`
    } = typeof t == "string" ? { name: t } : t;
    We.set(n, [r, o]);
  }
}
function To(e) {
  We.clear(), Gr(e);
}
let Jr = 0;
function Qr() {
  return `__theme_observer_${Jr++}__`;
}
function Zr(e) {
  if (!D) return;
  const t = document.createElement("div");
  return t.id = Qr(), t.className = Le, t.role = "none", t.style.cssText = "position: fixed; top -10px; left: -10px; height: 1px; visibility: hidden;", xe(t, (n) => {
    var o;
    if (!D) return;
    const r = ((o = n.borderBoxSize) == null ? void 0 : o[0].inlineSize) ?? n.contentRect.width;
    e.value = rt.get(r);
  }), t;
}
function eo() {
  const e = {};
  return Q(() => {
    Object.keys(e).forEach((t) => {
      clearTimeout(e[t]);
    });
  }), { timer: e };
}
function to() {
  const e = {};
  return Q(() => {
    Object.keys(e).forEach((t) => {
      clearInterval(e[t]);
    });
  }), { timer: e };
}
function no() {
  const e = {};
  return Q(() => {
    Object.keys(e).forEach((t) => {
      cancelAnimationFrame(e[t]);
    });
  }), { timer: e };
}
function So() {
  const { timer: e } = eo(), { timer: t } = to(), { timer: n } = no();
  return { timeout: e, interval: t, raf: n };
}
function Oo(e, t, n = 100) {
  let r;
  function o() {
    e.value === "hover" && (clearTimeout(r), r = setTimeout(() => {
      t.value = !0;
    }, n));
  }
  function i() {
    e.value === "hover" && (clearTimeout(r), r = setTimeout(() => {
      t.value = !1;
    }, n));
  }
  function s() {
    e.value === "click" && (t.value = !t.value);
  }
  return {
    handleTriggerEnter: o,
    handleTriggerLeave: i,
    handleTriggerClick: s
  };
}
function zo(e) {
  const {
    items: t,
    itemSize: n,
    itemFixed: r,
    idKey: o,
    defaultKeyAt: i,
    bufferSize: s = z(5),
    wrapper: c = z(null),
    autoResize: a = !0
  } = e, l = I(() => {
    const w = E(t), R = w.length, x = E(o), B = /* @__PURE__ */ new Map();
    for (let A = 0; A < R; ++A)
      B.set(w[A][x], A);
    return B;
  }), f = z(0), d = /* @__PURE__ */ new Map(), v = I(() => {
    const w = E(t), R = w.length, x = E(o), B = En(R, E(n));
    for (let A = 0; A < R; ++A) {
      const N = w[A][x], F = d.get(N);
      F && B.add(A, F);
    }
    return B;
  }), m = z(0), b = z(0), g = I(() => Math.max(
    v.value.boundIndex(b.value) - Math.max(E(s), 0),
    0
  )), p = I(() => {
    if (!f.value || f.value < 0) return [];
    const w = E(t), R = Math.min(
      v.value.boundIndex(b.value + f.value) + 1 + Math.max(E(s), 0),
      w.length
    );
    return w.slice(g.value, R);
  }), h = I(() => {
    m.value;
    const w = v.value.sum(), R = E(r);
    return {
      height: R ? `${w}px` : void 0,
      minHeight: R ? void 0 : `${w}px`,
      boxSizing: "content-box"
    };
  }), u = I(() => (m.value, {
    transform: `translate3d(0, ${v.value.sum(g.value)}px, 0)`
  }));
  if (Y(
    () => E(c),
    (w) => {
      w && Be(i) && requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          M(i);
        });
      });
    },
    { immediate: !0, flush: "post" }
  ), a) {
    let w = P;
    const R = Y(
      () => [E(c), a],
      ([x]) => {
        w(), x && (xe(x, T), w = () => {
          nt(x), w = P;
        }, Be(i) && M(i));
      },
      { immediate: !0, flush: "post" }
    );
    Q(() => {
      R(), w();
    });
  }
  function y() {
    const w = E(c);
    w && (b.value = w.scrollTop);
  }
  function O() {
    Mn(y);
  }
  function T(w) {
    bt(w.target) || w.contentRect.height === f.value || (f.value = w.contentRect.height);
  }
  function S(w, R) {
    var ht, mt;
    if (E(r)) return;
    const x = l.value.get(w), B = v.value, A = B.get(x), N = ((mt = (ht = R.borderBoxSize) == null ? void 0 : ht[0]) == null ? void 0 : mt.blockSize) ?? R.contentRect.height;
    if (N === A) return;
    if (bt(R.target)) {
      A && (B.add(x, -A), m.value++);
      return;
    }
    const F = N - E(n), W = N - A;
    if (F ? d.set(w, F) : d.delete(w), !W) return;
    B.add(x, W), m.value++;
    const G = E(c);
    if (G) {
      const hn = B.sum(x);
      G.scrollTop > hn && G.scrollBy(0, W), b.value = G.scrollTop;
    }
  }
  function C(w, R) {
    const x = E(c);
    x && x.scrollTo({
      behavior: R,
      top: w,
      left: 0
    });
  }
  function k(w, R) {
    const x = E(c);
    x && x.scrollBy({
      behavior: R,
      top: w,
      left: 0
    });
  }
  function M(w, R) {
    const x = l.value.get(w);
    x != null && L(x, R);
  }
  function L(w, R) {
    const x = E(c);
    x && x.scrollTo({
      behavior: R,
      top: v.value.sum(w),
      left: 0
    });
  }
  function $(w, R) {
    const x = E(c);
    if (!x) return;
    const B = v.value, A = x.scrollTop;
    if (B.sum(w) < A) {
      L(w, R);
      return;
    }
    const F = x.offsetHeight, W = A + F, G = B.sum(w + 1);
    G > W && C(G - F, R);
  }
  function _(w, R) {
    const x = l.value.get(w);
    x != null && $(x, R);
  }
  return {
    wrapper: c,
    indexMap: l,
    heightTree: v,
    startIndex: g,
    scrollOffset: b,
    visibleItems: p,
    listStyle: h,
    itemsStyle: u,
    handleScroll: O,
    handleResize: T,
    handleItemResize: S,
    scrollTo: C,
    scrollBy: k,
    scrollToKey: M,
    scrollToIndex: L,
    ensureIndexInView: $,
    ensureKeyInView: _
  };
}
export {
  qt as CLICK_OUTSIDE,
  Gr as addActiveThemes,
  so as createSlotRender,
  co as flatVNodes,
  bt as isHiddenElement,
  xe as observeResize,
  fo as pickToRefs,
  xo as placementWhileList,
  ao as proxyExposed,
  Vt as queryOutsideHiddenElement,
  To as setActiveThemes,
  nt as unobserveResize,
  Se as unrefElement,
  oo as useClickOutside,
  io as useDisplay,
  uo as useFullScreen,
  ho as useHover,
  mo as useIntersection,
  J as useListener,
  vo as useManualRef,
  po as useModifier,
  go as useMounted,
  bo as useMoving,
  yo as usePointer,
  Eo as usePopper,
  no as useRaf,
  wo as useResize,
  Kr as useRtl,
  to as useSetInterval,
  eo as useSetTimeout,
  Ro as useTheme,
  So as useTimerRecord,
  Oo as useTriggerHandler,
  zo as useVirtual,
  lo as watchPauseable
};
//# sourceMappingURL=index.mjs.map
